<template>
  <div
    ref="containerRef"
    :data-component-id="props.nodeId"
    class="card2-wrapper"
    @click="handleWrapperClick"
    @contextmenu="handleContextMenu"
    @mouseenter="handleMouseEnter"
    @mouseleave="handleMouseLeave"
    @focus="handleFocus"
    @blur="handleBlur"
  >
    <!-- ğŸ”¥ Component rendering - Based on unified configuration architecture -->
    <component
      v-if="currentComponentDef?.component"
      :is="currentComponentDef.component"
      ref="currentComponentRef"
      :config="displayData"
      :data="componentDataFromWarehouse"
      :component-id="props.nodeId"
      class="card2-component"
    />

    <!-- ğŸ”¥ First level debuggingï¼šCard2Wrapper Data passed to the component -->
    <div v-if="props.componentType === 'digit-indicator'" class="card2-wrapper-debug">
      <div class="debug-title">ğŸ”¥ Card2Wrapper data transferï¼ˆfirst levelï¼‰:</div>
      <div class="debug-content">
        <div>passed to the component data: {{ JSON.stringify(componentDataFromWarehouse) }}</div>
        <div>Timestamp: {{ new Date().toLocaleTimeString() }}</div>
      </div>
    </div>

    <!-- Component loading failure prompt -->
    <n-alert v-else-if="!currentComponentDef?.component" type="error" size="small">
      components {{ props.componentType }} Not found or failed to load
    </n-alert>
  </div>
</template>

<script setup lang="ts">
/**
 * ğŸ”¥ Card2Wrapper - Unified configuration architecture version
 * Based on the new unified configuration architectureï¼ŒImplement complete configuration management
 */

import { ref, onMounted, onUnmounted, computed, inject, nextTick, watch } from 'vue'
import { NAlert } from 'naive-ui'
import { useComponentTree as useCard2Integration } from '@/card2.1/hooks/useComponentTree'
import { useCard2Props } from '@/card2.1/hooks/useCard2Props'
import { usePreviewMode } from '@/components/visual-editor/hooks/usePreviewMode'
// ğŸ”¥ Import loop protection manager
import { loopProtectionManager } from '@/utils/LoopProtectionManager'
import type {
  InteractionConfig,
  InteractionEventType,
  InteractionResponse,
  ComponentInteractionCapability
} from '@/card2.1/core/interaction-types'
import type { UnifiedCard2Configuration } from '@/card2.1/hooks/useCard2Props'
// ğŸ”¥ importDataWarehouseTo obtain the data source execution resultsï¼ˆCompatibility preservedï¼‰
import { dataWarehouse } from '@/core/data-architecture/DataWarehouse'
// ğŸ”¥ Import configuration managers and data bridges
import { configurationIntegrationBridge as configurationManager } from '@/components/visual-editor/configuration/ConfigurationIntegrationBridge'
import { simpleDataBridge } from '@/core/data-architecture/SimpleDataBridge'
// ğŸ”¥ Import interactive configuration router
import { interactionConfigRouter } from '@/components/visual-editor/configuration/InteractionConfigRouter'

// ğŸš€ Newï¼šimportCard2.1 CoreResponsive data binding system
import { dataBindingManager } from '@/card2.1/core/data-source/data-binding-manager'
import { reactiveDataManager } from '@/card2.1/core/data-source/reactive-data-manager'
import { ComponentRegistry } from '@/card2.1/core/component-registry'
import { dataSourceMapper } from '@/card2.1/core/data-source-mapper'
import type { ComponentDataBinding, DataBindingStatus } from '@/card2.1/core/data-source/data-binding-manager'

interface Props {
  componentType: string
  config?: any
  data?: any
  nodeId: string
  previewMode?: boolean
}

const props = withDefaults(defineProps<Props>(), {
  previewMode: false
})

// base reference
const currentComponentRef = ref<any>(null)
const containerRef = ref<HTMLElement | null>(null)

// Get component definition
const { filteredComponents } = useCard2Integration()
const currentComponentDef = computed(() => {
  const found = filteredComponents.value?.find((comp: any) => comp.type === props.componentType)

  // ğŸ”¥ repairï¼šIf the component is not found and the component list is emptyï¼ŒWait for system initialization
  if (!found && filteredComponents.value.length === 0 && props.componentType) {
    if (import.meta.env.DEV) console.warn(`âš ï¸ [Card2Wrapper] components ${props.componentType} not foundï¼ŒWait for system initialization`)
  }

  return found
})

// Inject editor context
const editorContext = inject('editorContext', null) as any

// ğŸ”¥ Inject component executor registry
const componentExecutorRegistry = inject('componentExecutorRegistry', null) as Map<string, () => Promise<void>> | null

// ğŸ”¥ Preview mode detection
const { isPreviewMode } = usePreviewMode()

// ğŸš€ Card2.1 CoreReactive data binding state
const card2CoreDataBinding = ref<string | null>(null)
const card2CoreBindingStatus = ref<DataBindingStatus>({})
const card2CoreData = ref<Record<string, any>>({})
const useCard2CoreDataBinding = ref(false)

// ğŸš€ Check if the component supportsCard2.1 Coredata binding
const checkCard2CoreSupport = () => {
  const isRegistered = ComponentRegistry.has(props.componentType)
  const dataSourceKeys = ComponentRegistry.getDataSourceKeys(props.componentType)
  const supportsDataBinding = isRegistered && dataSourceKeys.length > 0

  console.log(`ğŸš€ [Card2Wrapper] Card2.1 CoreSupport checking ${props.nodeId}:`, {
    componentType: props.componentType,
    isRegistered,
    dataSourceKeys,
    supportsDataBinding
  })

  useCard2CoreDataBinding.value = supportsDataBinding
  return supportsDataBinding
}

// ğŸš€ initializationCard2.1 Coredata binding
const initializeCard2CoreBinding = async () => {
  if (!useCard2CoreDataBinding.value) {
    console.log(`ğŸš€ [Card2Wrapper] components ${props.componentType} Not supportedCard2.1 Coredata binding`)
    return
  }

  try {
    console.log(`ğŸš€ [Card2Wrapper] Start initializationCard2.1 Coredata binding ${props.nodeId}`)

    // Create component data binding configuration
    const bindingConfig: ComponentDataBinding = {
      componentId: props.nodeId,
      dataSourceId: `${props.nodeId}-datasource`, // Temporary data sourceID
      bindingConfig: {
        // Automatically generate binding configurations based on component definitions
        ...generateBindingConfig()
      }
    }

    // Create binding
    const bindingId = dataBindingManager.createBinding(bindingConfig)
    card2CoreDataBinding.value = bindingId

    // Subscribe to data updates
    dataBindingManager.subscribe(bindingId, (newData) => {
      console.log(`ğŸš€ [Card2Wrapper] Card2.1 CoreData update ${props.nodeId}:`, newData)
      card2CoreData.value = newData

      // ğŸ”¥ Update binding status
      const status = dataBindingManager.getBindingStatus(bindingId)
      if (status) {
        card2CoreBindingStatus.value = status
      }
    })

    console.log(`âœ… [Card2Wrapper] Card2.1 CoreData binding initialization completed ${props.nodeId}`)
  } catch (error) {
    console.error(`âŒ [Card2Wrapper] Card2.1 CoreData binding initialization failed ${props.nodeId}:`, error)
  }
}

// ğŸš€ Generate binding configuration
const generateBindingConfig = () => {
  const dataSourceKeys = ComponentRegistry.getDataSourceKeys(props.componentType)
  const bindingConfig: Record<string, any> = {}

  dataSourceKeys.forEach(key => {
    bindingConfig[key] = {
      dataPath: key,
      fallbackValue: null
    }
  })

  console.log(`ğŸš€ [Card2Wrapper] Generate binding configuration ${props.componentType}:`, bindingConfig)
  return bindingConfig
}

// ğŸš€ clean upCard2.1 Corebinding
const cleanupCard2CoreBinding = () => {
  if (card2CoreDataBinding.value) {
    dataBindingManager.removeBinding(card2CoreDataBinding.value)
    card2CoreDataBinding.value = null
    card2CoreData.value = {}
    card2CoreBindingStatus.value = {}
    console.log(`ğŸš€ [Card2Wrapper] CleanedCard2.1 Coredata binding ${props.nodeId}`)
  }
}

// ğŸ”¥ critical fixï¼šPerformance-optimized data source acquisition - solve200+Frequent calculation problem of components
let lastDataHash = ''
let cachedWarehouseData = {}
let dataFetchDebounce: NodeJS.Timeout | null = null

// ğŸ”¥ How to force clear cache
const clearDataCache = () => {
  lastDataHash = ''
  cachedWarehouseData = {}
  console.log('ğŸ”¥ [Card2Wrapper] Data cache cleared:', props.nodeId)
}

const componentDataFromWarehouse = computed(() => {
  // ğŸš¨ **Highest priority debugging**ï¼šConfirm that computed property execution begins
  console.log('ğŸš¨ [Card2Wrapper] ===== Computed property starts execution =====', {
    nodeId: props.nodeId,
    timestamp: new Date().toLocaleTimeString()
  })

  try {
    // ğŸš€ priority useCard2.1 CoreReactive data binding
    if (useCard2CoreDataBinding.value && Object.keys(card2CoreData.value).length > 0) {
      console.log('ğŸš€ [Card2Wrapper] useCard2.1 Coredata:', {
        nodeId: props.nodeId,
        card2CoreData: card2CoreData.value,
        bindingStatus: card2CoreBindingStatus.value,
        timestamp: new Date().toISOString()
      })
      return card2CoreData.value
    }

    // ğŸš¨ **critical fix**ï¼šDirectly bypassDataWarehouseresponsiveï¼ŒGet latest data manually
    console.log('ğŸš¨ [Card2Wrapper] directly fromDataWarehouseGet the latest data')

    // Force clear cacheï¼ŒMake sure you get the latest data
    dataWarehouse.clearComponentMergedCache(props.nodeId)

    // call directlyDataWarehouseGet dataï¼ŒBypassing reactive dependency issues
    const latestData = dataWarehouse.getComponentData(props.nodeId)

    console.log('ğŸš¨ [Card2Wrapper] The latest data obtained:', {
      nodeId: props.nodeId,
      latestData,
      dataType: typeof latestData,
      dataKeys: latestData && typeof latestData === 'object' ? Object.keys(latestData) : null,
      timestamp: new Date().toLocaleTimeString()
    })

    return latestData || {}
  } catch (error) {
    if (import.meta.env.DEV) console.error(`âŒ [Card2Wrapper] Failed to get data ${props.nodeId}:`, error)
    return {}
  }
})

// ğŸ”¥ coreï¼šUse unified configuration management
const {
  config: componentConfig,
  displayData,
  unifiedConfig,
  updateConfig,
  updateUnifiedConfig,
  getFullConfiguration,
  setConfigChangeCallback,
  syncToEditor
} = useCard2Props({
  config: props.config || {},
  data: componentDataFromWarehouse, // ğŸ”¥ critical fixï¼šPassing reactive computed propertiesï¼Œinstead of a static value
  componentId: props.nodeId,
  initialUnifiedConfig: getInitialUnifiedConfig()
})

/**
 * Get initial unified configuration
 * Get an existing configuration from the editor context or other source
 */
function getInitialUnifiedConfig() {
  try {
    if (editorContext?.getNodeById) {
      const node = editorContext.getNodeById(props.nodeId)
      if (import.meta.env.DEV) console.log(`ğŸ”¥ [Card2Wrapper] Get initial unified configuration ${props.nodeId}:`, {
        node: !!node,
        hasMetadata: !!node?.metadata,
        hasUnifiedConfig: !!node?.metadata?.unifiedConfig,
        hasInteractionConfig: !!node?.metadata?.unifiedConfig?.interaction,
        interactionConfigs: node?.metadata?.unifiedConfig?.interaction?.configs
      })
      if (node?.metadata?.unifiedConfig) {
        return node.metadata.unifiedConfig
      }
    }
  } catch (error) {
    if (import.meta.env.DEV) console.warn(`[Card2Wrapper] Failed to obtain initial configuration:`, error)
  }
  return undefined
}

if (import.meta.env.DEV) console.log(`ğŸ”¥ [Card2Wrapper] Unified configuration architecture initialization completed ${props.nodeId}:`, {
  componentType: props.componentType,
  hasUnifiedConfig: !!unifiedConfig.value,
  hasComponentConfig: !!componentConfig.value,
  isPreviewMode: isPreviewMode.value,
  interactionEnabled: isPreviewMode.value
})

// Configuration change callback
setConfigChangeCallback((config) => {
  if (import.meta.env.DEV) console.log(`ğŸ”¥ [Card2Wrapper] Configuration change callback ${props.nodeId}:`, config)
})

// ================== Interactive system integration ==================

// ğŸ”¥ Unified configuration centerï¼šInteraction configuration is based on unifiedConfig
const interactionConfigs = computed<InteractionConfig[]>(() => {
  return unifiedConfig.value.interaction?.configs || []
})

// ğŸ”¥ Unified configuration centerï¼šThe data source configuration is based on unifiedConfig
const dataSourceConfig = computed(() => {
  return unifiedConfig.value.dataSource || {}
})

// Get the interactive capabilities of a component
const componentInteractionCapability = computed<ComponentInteractionCapability | undefined>(() => {
  return currentComponentDef.value?.interactionCapabilities
})

// ğŸ”¥ Field level mapping functionï¼šDetermine which configuration layer the field should be updated to
const isBaseLayerField = (field: string): boolean => {
  // baselayer fieldï¼šDevice bindingã€UIBasic configuration
  const baseFields = [
    'deviceId', 'metricsList', // Device binding fields
    'title', 'showTitle', 'visible', 'opacity', // UIBasic fields
    'backgroundColor', 'borderWidth', 'borderColor', 'borderStyle', 'borderRadius',
    'padding', 'margin'
  ]
  return baseFields.includes(field)
}

const isDataSourceLayerField = (field: string): boolean => {
  // dataSourcelayer fieldï¼šData binding configuration
  const dataSourceFields = [
    'dataSourceConfig', 'fieldMappings', 'refreshInterval', 'autoRefresh'
  ]
  return dataSourceFields.includes(field)
}

const isInteractionLayerField = (field: string): boolean => {
  // interactionlayer fieldï¼šInteractive configuration
  const interactionFields = [
    'interactions', 'clickActions', 'hoverActions', 'eventHandlers'
  ]
  return interactionFields.includes(field)
}

// ğŸ”¥ Execute interactive responses in batches - Solve the problem of mutual overwriting of multiple attribute modifications
const executeBatchedInteractionResponses = async (responses: InteractionResponse[]) => {
  if (import.meta.env.DEV) console.log(`ğŸ¯ [Card2Wrapper] Execute interactive responses in batches:`, responses)

  // by componentIDand action type group responses
  const groupedResponses = {
    self: { modify: [] as InteractionResponse[], other: [] as InteractionResponse[] },
    cross: new Map<string, InteractionResponse[]>(),  // componentId -> responses
    nonModify: [] as InteractionResponse[]  // Non-modification actions such as jumps
  }

  // Classify all responses
  for (const response of responses) {
    if (response.action === 'modify' || response.action === 'modifyProperty' || response.action === 'updateComponentData') {
      if (response.modifyConfig) {
        const { targetComponentId } = response.modifyConfig

        if (targetComponentId === props.nodeId) {
          // modify yourself
          groupedResponses.self.modify.push(response)
        } else {
          // Modify other components
          if (!groupedResponses.cross.has(targetComponentId)) {
            groupedResponses.cross.set(targetComponentId, [])
          }
          groupedResponses.cross.get(targetComponentId)!.push(response)
        }
      }
    } else {
      // non-modifying actionï¼ˆJump etc.ï¼‰
      groupedResponses.nonModify.push(response)
    }
  }

  if (import.meta.env.DEV) console.log(`ğŸ¯ [Card2Wrapper] Response grouping results:`, {
    Modify from component: groupedResponses.self.modify.length,
    Modify across components: Array.from(groupedResponses.cross.entries()).map(([id, resps]) => ({ id, count: resps.length })),
    non-modifying action: groupedResponses.nonModify.length
  })

  // ğŸ”¥ critical fix1ï¼šBatch processing of self-component property modifications
  if (groupedResponses.self.modify.length > 0) {
    const batchedSelfUpdates = {}

    groupedResponses.self.modify.forEach(response => {
      if (response.modifyConfig) {
        const { targetProperty, updateValue } = response.modifyConfig
        batchedSelfUpdates[targetProperty] = updateValue
        if (import.meta.env.DEV) console.log(`ğŸ¯ [Card2Wrapper] Collected from component modifications: ${targetProperty} = ${updateValue}`)
      }
    })

    if (import.meta.env.DEV) console.log(`ğŸ¯ [Card2Wrapper] Modify your own properties in batches:`, batchedSelfUpdates)

    // ğŸ”¥ Restore original logicï¼šFor modifying self-components updateConfigï¼ŒStay in sync with configuration forms
    updateConfig('component', batchedSelfUpdates)
    if (import.meta.env.DEV) console.log(`âœ… [Card2Wrapper] Batch modification of self-components completed`)
  }

  // ğŸ”¥ critical fix2ï¼šBatch processing of cross-component property modifications
  for (const [targetComponentId, targetResponses] of groupedResponses.cross.entries()) {
    // ğŸ”¥ Tiered collection configuration updates - Assigned to different configuration layers based on field characteristics
    const layeredUpdates = {
      base: {},        // Basic configuration such as device binding
      component: {},   // Component specific properties
      dataSource: {}, // Data source configuration
      interaction: {} // Interactive configuration
    }

    targetResponses.forEach(response => {
      if (response.modifyConfig) {
        const { targetProperty, updateValue } = response.modifyConfig

        // ğŸ”¥ Processing field names with hierarchical prefixesï¼ˆlike "base.deviceId"ï¼‰
        let actualProperty = targetProperty
        let targetLayer = 'component' // Default level

        if (targetProperty.includes('.')) {
          const [layerPrefix, fieldName] = targetProperty.split('.')
          actualProperty = fieldName
          targetLayer = layerPrefix
    if (import.meta.env.DEV) console.log(`ğŸ¯ [Card2Wrapper] Level prefix detected: ${layerPrefix}.${fieldName}`)
        } else {
          // ğŸ”¥ Field level mappingï¼šDetermine which configuration layer should be updated based on the field name
          if (isBaseLayerField(targetProperty)) {
            targetLayer = 'base'
          } else if (isDataSourceLayerField(targetProperty)) {
            targetLayer = 'dataSource'
          } else if (isInteractionLayerField(targetProperty)) {
            targetLayer = 'interaction'
          }
        }

        // Collect updates based on target level
        layeredUpdates[targetLayer][actualProperty] = updateValue
    if (import.meta.env.DEV) console.log(`ğŸ¯ [Card2Wrapper] collect${targetLayer}Layer modification: ${targetComponentId}.${actualProperty} = ${updateValue}`)
      }
    })

    if (import.meta.env.DEV) console.log(`ğŸ¯ [Card2Wrapper] Modify other components in batches ${targetComponentId}:`, layeredUpdates)

    try {
      // ğŸ”¥ Hierarchical batch updateï¼šUpdated separately by configuration level
      for (const [layer, updates] of Object.entries(layeredUpdates)) {
        if (Object.keys(updates).length > 0) {
    if (import.meta.env.DEV) console.log(`ğŸ¯ [Card2Wrapper] renew${layer}layer:`, updates)
          configurationManager.updateConfigurationForInteraction(
            targetComponentId,
            layer as keyof UnifiedCard2Configuration,
            updates,
            'cross-component-interaction'
          )
        }
      }
    if (import.meta.env.DEV) console.log(`âœ… [Card2Wrapper] Cross-component hierarchical batch modification completed: ${targetComponentId}`)
    } catch (error) {
    if (import.meta.env.DEV) console.error(`âŒ [Card2Wrapper] Cross-component hierarchical batch modification fails ${targetComponentId}:`, error)
    }
  }

  // Handle non-modification actionsï¼ˆJump etc.ï¼‰
  for (const response of groupedResponses.nonModify) {
    if (import.meta.env.DEV) console.log(`ğŸ¯ [Card2Wrapper] Perform non-modification response:`, response)
    const delay = response.delay || 0
    setTimeout(() => {
      executeInteractionResponse(response)
    }, delay)
  }
}

// interactive event executorï¼ˆHandle non-attribute modification actionsï¼‰
const executeInteractionResponse = async (response: InteractionResponse) => {
    if (import.meta.env.DEV) console.log(`ğŸ¯ [Card2Wrapper] Perform interactive responses:`, response)

  try {
    switch (response.action) {
      case 'navigateToUrl':
      case 'jump':
    if (import.meta.env.DEV) console.log(`ğŸ¯ [Card2Wrapper] Handle jump actions:`, response)
        // Support multipleURLData format
        let url = response.jumpConfig?.url || response.value || response.url
        let target = response.jumpConfig?.target || response.target || '_self'

        if (url) {
    if (import.meta.env.DEV) console.log(`ğŸ¯ [Card2Wrapper] Execution jump: ${url} (${target})`)
          if (target === '_self') {
            window.location.href = url
          } else {
            window.open(url, target)
          }
        } else {
    if (import.meta.env.DEV) console.warn(`ğŸ¯ [Card2Wrapper] JumpURLnot found:`, response)
        }
        break

      case 'updateComponentData':
      case 'modifyProperty':
      case 'modify':
        // ğŸ”¥ Repair instructionsï¼šProperty modifications are now made by executeBatchedInteractionResponses Batch processing
    if (import.meta.env.DEV) console.log(`ğŸ¯ [Card2Wrapper] Property modifications have been processed by the batch processing functionï¼ŒSkip separate execution`)
        break

      case 'changeVisibility':
        // change visibility
        if (containerRef.value) {
          containerRef.value.style.visibility = response.value === 'visible' ? 'visible' : 'hidden'
        }
        break

      case 'changeBackgroundColor':
        // Change background color
        if (containerRef.value) {
          containerRef.value.style.backgroundColor = response.value
        }
        break

      case 'triggerAnimation':
        // trigger animation
        if (containerRef.value && response.value) {
          containerRef.value.style.animation = `${response.value} ${response.duration || 300}ms ease`
          setTimeout(() => {
            if (containerRef.value) {
              containerRef.value.style.animation = ''
            }
          }, response.duration || 300)
        }
        break

      default:
    if (import.meta.env.DEV) console.warn(`ğŸ¯ [Card2Wrapper] Unsupported interaction:`, response.action)
    }
  } catch (error) {
    if (import.meta.env.DEV) console.error(`ğŸ¯ [Card2Wrapper] Interactive response execution failed:`, error)
  }
}

// Universal interaction event handler
const handleInteractionEvent = async (eventType: InteractionEventType, event?: Event) => {
  // ğŸ”¥ critical fixï¼šDisable interaction in edit modeï¼ŒAvoid conflicts with editing operations
  if (!isPreviewMode.value) {
    if (import.meta.env.DEV) console.log(`ğŸ”¥ [Card2Wrapper] Interaction is disabled in edit mode ${eventType} for ${props.nodeId}`)
    return // No interaction is performed in edit mode
  }

  if (!componentInteractionCapability.value?.supportedEvents.includes(eventType)) {
    if (import.meta.env.DEV) console.log(`ğŸ¯ [Card2Wrapper] Component does not support event type ${eventType}`)
    return // The component does not support this event type
  }

    if (import.meta.env.DEV) console.log(`ğŸ¯ [Card2Wrapper] Handling interactive events in preview mode ${eventType} for ${props.nodeId}`, {
    totalConfigs: interactionConfigs.value.length,
    configs: interactionConfigs.value,
    // ğŸ”¥ Add debugging information
    configEvents: interactionConfigs.value.map(c => c.event),
    enabledConfigs: interactionConfigs.value.filter(c => c.enabled !== false),
    matchingConfigs: interactionConfigs.value.filter(config => config.event === eventType && config.enabled !== false)
  })

  // Execute matching interaction configuration
  const matchingConfigs = interactionConfigs.value.filter(config =>
    config.event === eventType && config.enabled !== false
  )

    if (import.meta.env.DEV) console.log(`ğŸ¯ [Card2Wrapper] Matching configuration found:`, matchingConfigs)

  // ğŸ”¥ critical fixï¼šAll matching configuredresponsesmergeï¼ŒAvoid multiple configurations overwriting each other
  const allResponses: InteractionResponse[] = []
  for (const config of matchingConfigs) {
    if (import.meta.env.DEV) console.log(`ğŸ¯ [Card2Wrapper] Collect configuration responses:`, config)
    allResponses.push(...config.responses)
  }

    if (import.meta.env.DEV) console.log(`ğŸ¯ [Card2Wrapper] Combine all responses for batch processing:`, {
    Total number of configurations: matchingConfigs.length,
    total responses: allResponses.length,
    response list: allResponses
  })

  // Batch all responses at onceï¼ŒAvoid configurations overwriting each other
  if (allResponses.length > 0) {
    await executeBatchedInteractionResponses(allResponses)
  }
}

// ================== event handling ==================

const handleWrapperClick = async (event: MouseEvent) => {
    if (import.meta.env.DEV) console.log(`ğŸ”¥ [Card2Wrapper] click event ${props.nodeId} (preview mode: ${isPreviewMode.value})`)

  // Perform interactive responsesï¼ˆThere is already a preview mode check internallyï¼‰
  await handleInteractionEvent('click', event)

  // Original preview mode logic remains compatible
  if (!props.previewMode) return
}

const handleContextMenu = (event: MouseEvent) => {
    if (import.meta.env.DEV) console.log(`ğŸ”¥ [Card2Wrapper] right click menu ${props.nodeId}`)
  event.preventDefault() // Block default right-click menu
}

// Added interactive event handler function
const handleMouseEnter = async (event: MouseEvent) => {
    if (import.meta.env.DEV) console.log(`ğŸ¯ [Card2Wrapper] mouse enter ${props.nodeId} (preview mode: ${isPreviewMode.value})`)
  await handleInteractionEvent('hover', event)
}

const handleMouseLeave = (event: MouseEvent) => {
    if (import.meta.env.DEV) console.log(`ğŸ¯ [Card2Wrapper] mouse away ${props.nodeId} (preview mode: ${isPreviewMode.value})`)
  // hoverThe departure of an event can trigger some reset operations
}

const handleFocus = async (event: FocusEvent) => {
    if (import.meta.env.DEV) console.log(`ğŸ¯ [Card2Wrapper] get focus ${props.nodeId} (preview mode: ${isPreviewMode.value})`)
  await handleInteractionEvent('focus', event)
}

const handleBlur = async (event: FocusEvent) => {
    if (import.meta.env.DEV) console.log(`ğŸ¯ [Card2Wrapper] lose focus ${props.nodeId} (preview mode: ${isPreviewMode.value})`)
  await handleInteractionEvent('blur', event)
}

// ğŸ”¥ Listen for configuration update events from the editor layer
const handleConfigUpdateEvent = (event: CustomEvent) => {
  const { componentId, layer, config } = event.detail
  if (componentId === props.nodeId) {
    if (import.meta.env.DEV) console.log(`ğŸ” [TRACE-8] Card2Wrapper.handleConfigUpdateEvent called:`, {
      componentId,
      layer,
      config,
      callStack: new Error().stack?.split('\n').slice(1, 5)
    })

    if (layer === 'interaction') {
    if (import.meta.env.DEV) console.log(`ğŸ” [TRACE-9] This is interaction Configure update events:`, {
        componentId,
        configsCount: config?.configs?.length || 0,
        willCallUpdateConfig: true,
        oldInteractionConfigs: interactionConfigs.value
      })

      // ğŸ”¥ Unified configuration centerï¼špassupdateConfigUpdate interaction configuration
      if (config?.configs) {
        updateConfig('interaction', { configs: config.configs })
    if (import.meta.env.DEV) console.log(`âœ… [Card2Wrapper] Interaction configuration has been updated through the Unified Configuration Center:`, {
          newConfigs: config.configs,
          configsCount: config.configs.length
        })
      }
    } else {
      // Non-interactive configuration is processed normally
      updateConfig(layer, config)
    }

    if (import.meta.env.DEV) console.log(`ğŸ” [TRACE-10] Card2Wrapper.handleConfigUpdateEvent Processing completed:`, {
      componentId,
      layer
    })
  }
}

// ğŸ”¥ Respond to configuration request events
const handleConfigRequestEvent = (event: CustomEvent) => {
  const { componentId, layer } = event.detail
  if (componentId === props.nodeId) {
    if (import.meta.env.DEV) console.log(`ğŸ”¥ [Card2Wrapper] Configuration request event received ${componentId}:`, { layer })

    const fullConfig = getFullConfiguration()
    const requestedConfig = layer ? fullConfig[layer] : fullConfig

    // Send configuration response event
    window.dispatchEvent(new CustomEvent('card2-config-response', {
      detail: {
        componentId,
        layer,
        config: requestedConfig
      }
    }))
  }
}

// ================== Interactive configuration management ==================

// Update interaction configuration
const updateInteractionConfigs = (configs: InteractionConfig[]) => {
    if (import.meta.env.DEV) console.log(`ğŸ” [TRACE-11] Card2Wrapper.updateInteractionConfigs called:`, {
    nodeId: props.nodeId,
    configCount: configs.length,
    configs: configs,
    callStack: new Error().stack?.split('\n').slice(1, 5)
  })

    if (import.meta.env.DEV) console.log(`ğŸ” [TRACE-12] Update interactive configuration through unified configuration center:`, {
    nodeId: props.nodeId,
    configsLength: configs.length,
    willTriggerPersistence: true
  })

  // ğŸ”¥ Unified configuration centerï¼špass directlyupdateConfigrenewï¼ŒComputed properties automatically respond to
  updateConfig('interaction', { configs })

    if (import.meta.env.DEV) console.log(`ğŸ” [TRACE-13] updateConfig('interaction', { configs }) Call completed`)
}

// Get interaction configuration
const getInteractionConfigs = (): InteractionConfig[] => {
  return interactionConfigs.value
}

// Get component interaction capabilities
const getInteractionCapability = (): ComponentInteractionCapability | undefined => {
  return componentInteractionCapability.value
}

// ================== Property change monitoring system ==================

// Store the last attribute valueï¼Œused to detect changes
const previousValues = ref<Record<string, any>>({})

// monitordisplayDatachangeï¼ŒDetect property change events
watch(
  () => displayData.value,
  (newDisplayData, oldDisplayData) => {
    if (!isPreviewMode.value) {
      // Property change events are not processed in edit mode
      return
    }

    if (import.meta.env.DEV) console.log(`ğŸ¯ [Card2Wrapper] DisplayDataChange detection ${props.nodeId}:`, {
      newData: newDisplayData,
      oldData: oldDisplayData,
      interactionConfigsCount: interactionConfigs.value.length
    })

    // Check eachdataChangeInteractive configuration
    const dataChangeConfigs = interactionConfigs.value.filter(config =>
      config.event === 'dataChange' && config.enabled !== false
    )

    if (import.meta.env.DEV) console.log(`ğŸ¯ [Card2Wrapper] DataChangeConfiguration:`, dataChangeConfigs)

    // ğŸ”¥ critical fixï¼šCollect all triggereddataChangeresponseï¼ŒPerform batch processing
    const triggeredResponses: InteractionResponse[] = []

    for (const config of dataChangeConfigs) {
      // ğŸ”¥ repairï¼šdataChangeThe listening properties of the event are stored inconfig.watchedPropertyï¼Œnoresponsemiddle
      if (config.watchedProperty) {
        const propertyPath = config.watchedProperty
        const newValue = getNestedValue(newDisplayData, propertyPath)
        const oldValue = getNestedValue(oldDisplayData || {}, propertyPath)

    if (import.meta.env.DEV) console.log(`ğŸ¯ [Card2Wrapper] Check for property changes:`, {
          property: propertyPath,
          newValue,
          oldValue,
          hasChanged: newValue !== oldValue,
          condition: config.condition
        })

        // If the attribute value changes
        if (newValue !== oldValue) {
          // Check execution conditionsï¼ˆuseconfig.conditioninstead ofresponse.executionConditionï¼‰
          if (checkDataChangeCondition(config.condition, newValue)) {
    if (import.meta.env.DEV) console.log(`ğŸ¯ [Card2Wrapper] Property changes trigger interaction:`, {
              property: propertyPath,
              value: newValue,
              condition: config.condition,
              responsesCount: config.responses.length
            })

            // ğŸ”¥ critical fixï¼šCollect responses instead of executing immediately
            triggeredResponses.push(...config.responses)
    if (import.meta.env.DEV) console.log(`ğŸ¯ [Card2Wrapper] collectdataChangeresponse ${config.responses.length} indivual`)
          } else {
    if (import.meta.env.DEV) console.log(`ğŸ¯ [Card2Wrapper] Condition not metï¼ŒNo interaction is performed:`, {
              property: propertyPath,
              value: newValue,
              condition: config.condition
            })
          }
        }
      }
    }

    // ğŸ”¥ critical fixï¼šExecute all triggered responses in batchesï¼ŒAvoid covering each other
    if (triggeredResponses.length > 0) {
    if (import.meta.env.DEV) console.log(`ğŸ¯ [Card2Wrapper] Batch executiondataChangetriggered ${triggeredResponses.length} responses`)

      // Delayed execution to avoid conflicts with synchronous updates
      setTimeout(async () => {
        await executeBatchedInteractionResponses(triggeredResponses)
      }, 100)
    }
  },
  { deep: true }
)

// Helper function for getting nested object property values
const getNestedValue = (obj: any, path: string): any => {
  if (!obj || !path) return undefined

  // Supports dot-separated pathsï¼Œlike 'base.deviceId' æˆ–ç®€å•å±æ€§like 'title'
  const keys = path.split('.')
  let current = obj

  for (const key of keys) {
    if (current && typeof current === 'object' && key in current) {
      current = current[key]
    } else {
      return undefined
    }
  }

  return current
}

// ğŸ”¥ dedicated todataChangeEvent condition checking function
const checkDataChangeCondition = (condition: any, currentValue: any): boolean => {
  if (!condition) return true // Execute directly without conditions

    if (import.meta.env.DEV) console.log(`ğŸ¯ [Card2Wrapper] examinedataChangeExecution conditions:`, {
    condition,
    currentValue,
    conditionType: condition.type,
    conditionOperator: condition.operator,
    conditionValue: condition.value
  })

  switch (condition.type) {
    case 'comparison':
      const operator = condition.operator || 'equals'
      const targetValue = condition.value

    if (import.meta.env.DEV) console.log(`ğŸ¯ [Card2Wrapper] DataChangecomparison conditions:`, {
        operator,
        currentValue,
        targetValue,
        result: compareValues(currentValue, targetValue, operator)
      })

      return compareValues(currentValue, targetValue, operator)

    case 'range':
      return checkRangeCondition(currentValue, condition.value)

    case 'expression':
      return checkExpressionCondition(currentValue, condition.value)

    default:
    if (import.meta.env.DEV) console.warn(`ğŸ¯ [Card2Wrapper] unknowndataChangecondition type:`, condition.type)
      return true
  }
}

// General execution condition checking functionï¼ˆfor other event typesï¼‰
const checkExecutionCondition = (response: any, currentValue: any): boolean => {
  const condition = response.executionCondition
  if (!condition) return true // Execute directly without conditions

    if (import.meta.env.DEV) console.log(`ğŸ¯ [Card2Wrapper] Check common execution conditions:`, {
    condition,
    currentValue,
    conditionType: condition.type,
    conditionValue: condition.value
  })

  switch (condition.type) {
    case 'equals':
    case 'comparison':
      const operator = condition.operator || '=='
      const targetValue = condition.value

    if (import.meta.env.DEV) console.log(`ğŸ¯ [Card2Wrapper] General comparison conditions:`, {
        operator,
        currentValue,
        targetValue,
        result: compareValues(currentValue, targetValue, operator)
      })

      return compareValues(currentValue, targetValue, operator)

    case 'range':
      return checkRangeCondition(currentValue, condition.value)

    case 'expression':
      return checkExpressionCondition(currentValue, condition.value)

    default:
    if (import.meta.env.DEV) console.warn(`ğŸ¯ [Card2Wrapper] Unknown generic condition type:`, condition.type)
      return true
  }
}

// value comparison function
const compareValues = (currentValue: any, targetValue: any, operator: string): boolean => {
  switch (operator) {
    case '==':
    case 'equals':
      return String(currentValue) === String(targetValue)
    case '!=':
    case 'notEquals':
      return String(currentValue) !== String(targetValue)
    case '>':
      return Number(currentValue) > Number(targetValue)
    case '>=':
      return Number(currentValue) >= Number(targetValue)
    case '<':
      return Number(currentValue) < Number(targetValue)
    case '<=':
      return Number(currentValue) <= Number(targetValue)
    default:
      return String(currentValue) === String(targetValue)
  }
}

// Range check function
const checkRangeCondition = (currentValue: any, rangeValue: string): boolean => {
  // Simple implementationï¼Œsupport "10-20" Format
  const range = rangeValue.split('-').map(v => Number(v.trim()))
  if (range.length === 2) {
    const numValue = Number(currentValue)
    return numValue >= range[0] && numValue <= range[1]
  }
  return false
}

// Expression checking function
const checkExpressionCondition = (currentValue: any, expression: string): boolean => {
  try {
    // Simple expression checkingï¼ŒWill${value}Replace with actual value
    const expr = expression.replace(/\${value}/g, String(currentValue))
    // A safe expression evaluator should be used hereï¼ŒTemporarily simplify processing
    return eval(expr)
  } catch (error) {
    if (import.meta.env.DEV) console.error(`ğŸ¯ [Card2Wrapper] Expression execution failed:`, expression, error)
    return false
  }
}

// ================== component executor ==================

/**
 * ğŸ”¥ critical fixï¼šLoop-proof component data source executor
 * This is registered to componentExecutorRegistry core function
 */
let executionInProgress = false
let lastExecutionConfig = ''
let executionDebounce: NodeJS.Timeout | null = null
// ğŸ”¥ Newï¼šExecution serial number trackingï¼ŒEnsure that only the latest execution results are applied
let currentExecutionSequence = 0
// ğŸ”¥ Newï¼šConfigure version trackingï¼ŒPrevent the use of outdated configurations
let lastConfigHash = ''

const executeComponentDataSource = async (): Promise<void> => {
  // ğŸ”¥ Generate the current execution sequence number
  currentExecutionSequence++
  const currentSequence = currentExecutionSequence
  const executionId = `${props.nodeId}-seq${currentSequence}-${Date.now()}`

  console.log(`ğŸ¯ Print these words as requested by the user - execution sequence number ${currentSequence}ï¼šCard2WrapperThe component executor starts executing ${props.nodeId}`)

  // ğŸ”¥ critical fixï¼šGet the latest configuration snapshot nowï¼ŒPrevent configuration changes during execution
  const configSnapshot = await captureLatestConfigurationSnapshot(executionId)
  if (!configSnapshot) {
    console.log(`ğŸ”¥ [Card2Wrapper] [${executionId}] Unable to obtain configuration snapshotï¼ŒSkip execution`)
    return
  }

  // ğŸ”¥ critical fixï¼šCheck configuration versionï¼ŒPrevent repeated execution of the same configuration
  const currentConfigHash = calculateConfigurationHash(configSnapshot.dataSource)
  if (currentConfigHash === lastConfigHash && currentConfigHash !== '') {
    console.log(`ğŸ”¥ [Card2Wrapper] [${executionId}] Configuration unchangedï¼ŒSkip repeated execution:`, {
      configHash: currentConfigHash,
      illustrate: 'The configuration content is the sameï¼ŒAvoid invalid repeated executions'
    })
    return
  }
  lastConfigHash = currentConfigHash

  // ğŸ”¥ cycle protectionï¼šCheck whether this execution should be allowed
  const callId = loopProtectionManager.markCallStart(
    'Card2Wrapper.executeComponentDataSource',
    props.nodeId,
    'data-source-execution'
  )

  if (!callId) {
    if (import.meta.env.DEV) console.warn(`ğŸš« [Card2Wrapper] Data source execution blocked by loop guard: ${props.nodeId}`)
    return
  }

  // ğŸ”¥ critical fix1ï¼šPrevent concurrent execution and recursive calls
  if (executionInProgress) {
    loopProtectionManager.markCallEnd(callId, 'Card2Wrapper.executeComponentDataSource', props.nodeId)
    if (import.meta.env.DEV) console.log(`ğŸ”¥ [Card2Wrapper] Skip concurrent execution ${props.nodeId}`)
    return
  }

  // ğŸ”¥ critical fix2ï¼šAnti-shake processingï¼ŒAvoid frequent triggering
  if (executionDebounce) {
    clearTimeout(executionDebounce)
  }

  return new Promise((resolve) => {
    executionDebounce = setTimeout(async () => {
      // ğŸ”¥ Check the serial number againï¼ŒMake sure this is the latest execution request
      if (currentSequence !== currentExecutionSequence) {
        console.log(`ğŸ”¥ [Card2Wrapper] The execution sequence number has expiredï¼ŒSkip execution ${props.nodeId}:`, {
          Current serial number: currentSequence,
          Latest serial number: currentExecutionSequence,
          illustrate: 'There is an updated execution requestï¼ŒCancel this execution'
        })
        resolve()
        return
      }

      if (executionInProgress) {
        resolve()
        return
      }

      executionInProgress = true
      try {
        // ğŸ”¥ critical fixï¼šUsing configuration snapshotsï¼Œinstead of reacquiringï¼ˆmay have expiredï¼‰
        const dataSourceConfig = configSnapshot.dataSource

        if (!dataSourceConfig) {
          console.log(`ğŸ”¥ [Card2Wrapper] [${executionId}] No data source configuration in configuration snapshotï¼ŒSkip execution`)
          resolve()
          return
        }

        // ğŸ”¥ critical fix3ï¼šUsing snapshot's configuration hashï¼ŒAvoid repeated checks
        console.log(`ğŸ”¥ [Card2Wrapper] [${executionId}] Execute data source using configuration snapshot:`, {
          configHash: currentConfigHash,
          executionSequence: currentSequence,
          snapshotTimestamp: configSnapshot.timestamp
        })

        // ğŸ¯ Print these words as requested by the user - stage0ï¼šCard2WrapperThe component executor is called
        if (process.env.NODE_ENV === 'development') {
    if (import.meta.env.DEV) console.log(`ğŸ¯ Print these words as requested by the user - stage0ï¼šCard2WrapperThe component executor is called`, {
            componentId: props.nodeId,
            componentType: props.componentType,
            Trigger mode: 'passcomponentExecutorRegistryRegistered executor',
            Prevent repeated execution: true,
            execution sequence number: currentSequence
          })
        }

        // ğŸ”¥ use VisualEditorBridge Execute data source
        const { getVisualEditorBridge } = await import('@/core/data-architecture/VisualEditorBridge')
        const visualEditorBridge = getVisualEditorBridge()

        // ğŸ”¥ critical fixï¼špass with executionIDFull configuration snapshot of
        const enhancedConfig = {
          ...configSnapshot,
          executionId,
          executionSequence: currentSequence,
          configHash: currentConfigHash
        }

        // Clear cache to ensure you get the latest data
        simpleDataBridge.clearComponentCache(props.nodeId)

        // Execute data source
        const result = await visualEditorBridge.updateComponentExecutor(
          props.nodeId,
          props.componentType,
          enhancedConfig
        )

        // ğŸ”¥ Check the serial number againï¼ŒMake sure this result remains up to date
        if (currentSequence !== currentExecutionSequence) {
          console.log(`ğŸ”¥ [Card2Wrapper] Execution completed but sequence number has expiredï¼Œdiscard results ${props.nodeId}:`, {
            execution sequence number: currentSequence,
            Latest serial number: currentExecutionSequence,
            executionId,
            illustrate: 'There is a new request during executionï¼ŒDiscard this result'
          })
          resolve()
          return
        }

        if (process.env.NODE_ENV === 'development') {
    if (import.meta.env.DEV) console.log(`ğŸ¯ Print these words as requested by the user - stage1ï¼šData source execution completedï¼ŒwaitDataWarehouseResponsive updates`, {
            componentId: props.nodeId,
            Execution result: result.success,
            Data content: result.data,
            executionId,
            execution sequence number: currentSequence
          })
        }

        // ğŸ”¥ After the data source execution is completedï¼ŒClear cache to force re-fetching of latest data
        clearDataCache()

        // ğŸ”¥ force clear DataWarehouse merge cache and trigger responsive updates
        dataWarehouse.clearComponentMergedCache(props.nodeId)

        // ğŸ”¥ Newï¼šDelay forced refreshï¼ŒEnsure data dissemination
        setTimeout(() => {
          forceDataRefresh()
        }, 100)

        resolve()
      } catch (error) {
    if (import.meta.env.DEV) console.error(`âŒ [Card2Wrapper] Data source execution failed ${props.nodeId}:`, error)
        resolve() // Even if you failresolveï¼Œavoid blocking
      } finally {
        executionInProgress = false
        executionDebounce = null
        // ğŸ”¥ cycle protectionï¼šMark the end of the call
        loopProtectionManager.markCallEnd(callId, 'Card2Wrapper.executeComponentDataSource', props.nodeId)
      }
    }, 300) // 300msAnti-shake delayï¼ŒAdapt to a large number of component scenarios
  })
}

// ğŸ”¥ Newï¼šUtility function to capture the latest configuration snapshot
const captureLatestConfigurationSnapshot = async (executionId: string): Promise<{ dataSource: any; base: any; timestamp: number } | null> => {
  try {
    const latestConfig = configurationManager.getConfiguration(props.nodeId)
    if (!latestConfig) {
      console.log(`ğŸ”¥ [Card2Wrapper] [${executionId}] Unable to get component configuration`)
      return null
    }

    const snapshot = {
      dataSource: latestConfig.dataSource ? JSON.parse(JSON.stringify(latestConfig.dataSource)) : null,
      base: latestConfig.base ? JSON.parse(JSON.stringify(latestConfig.base)) : null,
      timestamp: Date.now()
    }

    console.log(`ğŸ”¥ [Card2Wrapper] [${executionId}] Configuration snapshot captured:`, {
      hasDataSource: !!snapshot.dataSource,
      hasBase: !!snapshot.base,
      timestamp: snapshot.timestamp
    })

    return snapshot
  } catch (error) {
    console.error(`âŒ [Card2Wrapper] [${executionId}] Configuration snapshot capture failed:`, error)
    return null
  }
}

// ğŸ”¥ Newï¼šUtility function to calculate configuration hash value
const calculateConfigurationHash = (config: any): string => {
  try {
    if (!config) return ''
    const configString = JSON.stringify(config)
    let hash = 0
    for (let i = 0; i < configString.length; i++) {
      const char = configString.charCodeAt(i)
      hash = ((hash << 5) - hash) + char
      hash = hash & hash // Convert to32bit integer
    }
    return Math.abs(hash).toString(36)
  } catch (error) {
    return Date.now().toString(36)
  }
}

// ================== life cycle ==================

/**
 * ğŸ”¥ Initialize data source configuration - Trigger data source execution through configuration changes
 * This is the correct way to trigger datasource execution when entering the editor
 */
const initializeDataSourceConfiguration = async () => {
  try {
    if (import.meta.env.DEV) console.log(`ğŸ”¥ [Card2Wrapper] Initialize data source configuration ${props.nodeId}`)

    // Check if there is data source configuration
    const currentConfig = configurationManager.getConfiguration(props.nodeId)
    const hasDataSourceConfig = currentConfig?.dataSource

    if (hasDataSourceConfig) {
    if (import.meta.env.DEV) console.log(`ğŸ”¥ [Card2Wrapper] components ${props.nodeId} Have data source configurationï¼ŒTrigger configuration change execution`)

      // ğŸ”¥ keyï¼špass"touch"Configure to trigger executionï¼Œrather than executing it directly
      // This ensures that all listeners are triggered correctly
      configurationManager.updateConfiguration(
        props.nodeId,
        'dataSource',
        currentConfig.dataSource,
        props.componentType
      )
    } else {
    if (import.meta.env.DEV) console.log(`ğŸ”¥ [Card2Wrapper] components ${props.nodeId} No data source configurationï¼ŒSkip initialization`)
    }
  } catch (error) {
    if (import.meta.env.DEV) console.error(`âŒ [Card2Wrapper] Failed to initialize data source configuration ${props.nodeId}:`, error)
  }
}

// ğŸ”¥ Listen for component definition changesï¼Œmake suremetadataAlways in sync
watch(
  () => currentComponentDef.value,
  (newDef, oldDef) => {
    if (newDef && newDef !== oldDef && editorContext?.updateNode) {
      const currentNode = editorContext.getNodeById(props.nodeId)
      if (currentNode) {
        const updatedMetadata = {
          ...currentNode.metadata,
          card2Definition: newDef,
          lastDefinitionUpdate: Date.now()
        }

        editorContext.updateNode(props.nodeId, {
          metadata: updatedMetadata
        })

    if (import.meta.env.DEV) console.log(`ğŸ”¥ [Card2Wrapper] Component definition changesï¼ŒNode updatedmetadata ${props.nodeId}:`, {
          componentType: props.componentType,
          hasInteractionCapabilities: !!newDef?.interactionCapabilities,
          watchablePropertiesCount: Object.keys(newDef?.interactionCapabilities?.watchableProperties || {}).length
        })
      }
    }
  },
  { immediate: false }
)

// ğŸ”¥ monitor componentDataFromWarehouse change
watch(
  () => componentDataFromWarehouse.value,
  (newData, oldData) => {
    if (props.componentType === 'digit-indicator') {
      console.log('ğŸ”¥ [Card2Wrapper] componentDataFromWarehouse change:', {
        nodeId: props.nodeId,
        componentType: props.componentType,
        newData,
        oldData,
        newDataKeys: newData && typeof newData === 'object' ? Object.keys(newData) : 'Not an object',
        oldDataKeys: oldData && typeof oldData === 'object' ? Object.keys(oldData) : 'Not an object',
        timestamp: new Date().toISOString(),
        hasValidNewData: newData && typeof newData === 'object' && Object.keys(newData).length > 0
      })
    }
  },
  { deep: true, immediate: true }
)

// ğŸ”¥ Newï¼šForced data update mechanism - Manually triggered when the data source execution is completed
const forceDataRefresh = () => {
  console.log('ğŸ”¥ [Card2Wrapper] Force data refresh:', props.nodeId)
  // force clearDataWarehousecache
  dataWarehouse.clearComponentMergedCache(props.nodeId)

  // Manually triggering computed property recalculation
  nextTick(() => {
    const freshData = componentDataFromWarehouse.value
    console.log('ğŸ”¥ [Card2Wrapper] Data after forced refresh:', freshData)
  })
}

onMounted(async () => {
    if (import.meta.env.DEV) console.log(`ğŸ¯ Print these words as requested by the user - stageI0ï¼šCard2Wrappercomponents${props.nodeId}Start mounting`)
    if (import.meta.env.DEV) console.log(`ğŸ”¥ [Card2Wrapper] Component mounting completed ${props.nodeId}`)

  // ğŸš€ First initializeCard2.1 CoreResponsive data binding system
  checkCard2CoreSupport()
  if (useCard2CoreDataBinding.value) {
    await initializeCard2CoreBinding()
  }

  // ğŸ”¥ Force clear cacheï¼ŒMake sure you get the latest data
  clearDataCache()

  // ğŸš¨ **critical fix**ï¼šForce initialization of computed propertiesï¼ŒEstablishVueReactive dependencies
  console.log('ğŸš¨ [Card2Wrapper] Force initialization of computed propertiesï¼ŒCreate reactive dependencies:', props.nodeId)
  try {
    // Force access to computed propertiesï¼Œmake sureVueReactive systems track dependencies
    const initialData = componentDataFromWarehouse.value

  } catch (initError) {
    console.error('âŒ [Card2Wrapper] Failed to initialize computed property:', initError)
  }

  // ğŸ”¥ Newï¼šMake sure the component definition is injected into the node'smetadatamiddle
  if (currentComponentDef.value && editorContext?.updateNode) {
    const currentNode = editorContext.getNodeById(props.nodeId)
    if (currentNode) {
      const updatedMetadata = {
        ...currentNode.metadata,
        card2Definition: currentComponentDef.value,
        lastDefinitionUpdate: Date.now()
      }

      editorContext.updateNode(props.nodeId, {
        metadata: updatedMetadata
      })

    if (import.meta.env.DEV) console.log(`ğŸ”¥ [Card2Wrapper] The component definition has been injected into the nodemetadata ${props.nodeId}:`, {
        componentType: props.componentType,
        hasCard2Definition: !!currentComponentDef.value,
        hasInteractionCapabilities: !!currentComponentDef.value?.interactionCapabilities,
        watchableProperties: currentComponentDef.value?.interactionCapabilities?.watchableProperties
      })
    }
  }

  // ğŸ”¥ critical fixï¼šRegister the component executor to the executor registry
  if (componentExecutorRegistry) {
    componentExecutorRegistry.set(props.nodeId, executeComponentDataSource)

    // ğŸ”¥ critical fixï¼šAfter the executor is registeredï¼ŒCheck and retrigger execution of existing configurations
    nextTick(async () => {
      try {
        // Check if there is already a configurationï¼ˆillustratefetchBoardAlready executedï¼‰
        const existingConfig = configurationManager.getConfiguration(props.nodeId)
        if (existingConfig && existingConfig.dataSource) {
          // Call the executor directlyï¼ŒRe-execute the data source
          await executeComponentDataSource()
        } else {
          // No configurationï¼ŒPerform initialization
          await initializeDataSourceConfiguration()
        }
      } catch (error) {
         console.error(`âŒ [Card2Wrapper] Data source processing fails after component mounting ${props.nodeId}:`, error)
      }
    })
  }
  // ğŸ”¥ Commentï¼šData source initialization has taken place after executor registrationï¼ŒNo need to call repeatedly here
  // ğŸ”¥ Unified configuration centerï¼šInteraction configuration initialization is handled automatically by computed properties
  const savedConfigs = unifiedConfig.value.interaction?.configs as InteractionConfig[]
  // Listen for configuration updates and request events
  window.addEventListener('card2-config-update', handleConfigUpdateEvent as EventListener)
  window.addEventListener('card2-config-request', handleConfigRequestEvent as EventListener)

  // ğŸ”¥ Register the component instance to the interactive configuration router
  nextTick(() => {
    const componentExpose = {
      getFullConfiguration,
      updateConfig,
      updateUnifiedConfig,
      getDisplayData: () => displayData.value,
      getUnifiedConfig: () => unifiedConfig.value,
      updateInteractionConfigs,
      getInteractionConfigs,
      getInteractionCapability,
      watchProperty: (propertyName: string, callback: (newValue: any, oldValue: any) => void) => {
        if (currentComponentRef.value?.watchProperty) {
    if (import.meta.env.DEV) console.log(`ğŸ”¥ [Card2Wrapper] The proxy attribute listens to the component instance: ${propertyName}`)
          return currentComponentRef.value.watchProperty(propertyName, callback)
        } else {
    if (import.meta.env.DEV) console.warn(`ğŸ”¥ [Card2Wrapper] Component instance does not supportwatchPropertyï¼Œusefallbackmonitor`)
          return watch(
            () => unifiedConfig.value.component?.[propertyName],
            (newValue, oldValue) => {
              if (newValue !== oldValue) {
                callback(newValue, oldValue)
              }
            },
            { immediate: false }
          )
        }
      }
    }

    if (import.meta.env.DEV) console.log(`ğŸ”¥ [Card2Wrapper] Register component instance with router: ${props.nodeId}`)
    interactionConfigRouter.registerComponentInstance(props.nodeId, componentExpose)
  })
})

// Clean up event listening
onUnmounted(() => {
  // ğŸš€ clean upCard2.1 Coredata binding
  cleanupCard2CoreBinding()

  // ğŸ”¥ Clean up component executor registration
  if (componentExecutorRegistry) {
    componentExecutorRegistry.delete(props.nodeId)
    if (import.meta.env.DEV) console.log(`ğŸ”¥ [Card2Wrapper] The component executor has logged out ${props.nodeId}`)
  }

  // ğŸ”¥ Clean up component registration in interactive configuration router
  interactionConfigRouter.unregisterComponent(props.nodeId)
    if (import.meta.env.DEV) console.log(`ğŸ”¥ [Card2Wrapper] The interactive configuration router component has logged out ${props.nodeId}`)

  window.removeEventListener('card2-config-update', handleConfigUpdateEvent as EventListener)
  window.removeEventListener('card2-config-request', handleConfigRequestEvent as EventListener)
})

// ğŸ”¥ Expose the configuration management interface to the outside worldï¼ŒforNodeWrappercall
defineExpose({
  getFullConfiguration,
  updateConfig,
  updateUnifiedConfig,
  getDisplayData: () => displayData.value,
  getUnifiedConfig: () => unifiedConfig.value,
  // ğŸ¯ Interactive system related interfaces
  updateInteractionConfigs,
  getInteractionConfigs,
  getInteractionCapability,
  // ğŸ”¥ Newï¼šProperty listening interfaceï¼ŒFor use by interaction engines
  watchProperty: (propertyName: string, callback: (newValue: any, oldValue: any) => void) => {
    // Check if the current component instance haswatchPropertymethod
    if (currentComponentRef.value?.watchProperty) {
    if (import.meta.env.DEV) console.log(`ğŸ”¥ [Card2Wrapper] The proxy attribute listens to the component instance: ${propertyName}`)
      return currentComponentRef.value.watchProperty(propertyName, callback)
    } else {
    if (import.meta.env.DEV) console.warn(`ğŸ”¥ [Card2Wrapper] Component instance does not supportwatchPropertyï¼Œusefallbackmonitor`)
      // Fallbackï¼šmonitor unifiedConfig change
      return watch(
        () => unifiedConfig.value.component?.[propertyName],
        (newValue, oldValue) => {
          if (newValue !== oldValue) {
            callback(newValue, oldValue)
          }
        },
        { deep: true }
      )
    }
  }
})
</script>

<style scoped>
.card2-wrapper {
  position: relative;
  width: 100%;
  height: 100%;
  border-radius: 4px;
  overflow: hidden;
}

/* ğŸ”¥ Card2Wrapper debug style */
.card2-wrapper-debug {
  background: #e8f4ff;
  border: 2px solid #1890ff;
  border-radius: 4px;
  padding: 8px;
  margin-top: 8px;
  font-size: 12px;
}

.card2-wrapper-debug .debug-title {
  color: #1890ff;
  font-weight: bold;
  margin-bottom: 4px;
}

.card2-wrapper-debug .debug-content {
  background: #fff;
  padding: 4px;
  border-radius: 2px;
  font-family: monospace;
  word-break: break-all;
}

.card2-component {
  width: 100%;
  height: 100%;
}
</style>
