¬∑
<template>
  <div class="configuration-panel">
    <!-- Global settings (Displayed when no component is selected) -->
    <div v-if="!selectedWidget" class="global-settings">
      <h3 class="panel-title">{{ $t('config.global.title') }}</h3>

      <!-- Canvas global settings -->
      <n-form label-placement="left" label-width="auto" size="small" class="global-form">
        <n-form-item :label="$t('config.global.showWidgetTitles')">
          <n-switch :value="showWidgetTitles" @update:value="onToggleWidgetTitles" />
        </n-form-item>

        <n-form-item v-if="gridConfig" :label="$t('config.global.gridConfig')">
          <n-space vertical size="small">
            <div class="grid-config-item">
              <span>{{ $t('config.global.columns') }}:</span>
              <n-input-number
                v-model:value="gridConfig.colNum"
                :min="1"
                :max="48"
                size="small"
                @update:value="handleGridConfigChange"
              />
            </div>
            <div class="grid-config-item">
              <span>{{ $t('config.global.rowHeight') }}:</span>
              <n-input-number
                v-model:value="gridConfig.rowHeight"
                :min="20"
                :max="200"
                size="small"
                @update:value="handleGridConfigChange"
              />
            </div>
          </n-space>
        </n-form-item>
      </n-form>
    </div>

    <!-- Component configuration (Shown when component is selected) -->
    <div v-else class="widget-configuration">
      <!-- Configure panel title -->
      <div class="config-header">
        <h3 class="panel-title">{{ widgetDisplayName }} {{ $t('config.widget.settings') }}</h3>
      </div>

      <!-- Configure tab page - dynamic structure -->
      <n-tabs v-model:value="activeTab" type="line" animated size="small" class="config-tabs">
        <!-- Dynamically generate configuration tabs -->
        <n-tab-pane v-for="layer in configLayers" :key="layer.name" :name="layer.name" :tab="$t(layer.label)">
          <!-- BaseConfigure special handling -->
          <template v-if="layer.name === 'base'">
            <component
              :is="layer.component"
              v-model="baseConfig"
              :node-id="selectedWidget?.id || ''"
              :readonly="readonly"
              @apply="handleBaseConfigApply"
              @reset="handleBaseConfigReset"
            />
          </template>

          <!-- Special handling of component configuration -->
          <template v-else-if="layer.name === 'component'">
            <component
              :is="layer.component"
              v-model="componentConfig"
              :widget="selectedWidget"
              :readonly="readonly"
              @validate="handleValidation"
              @update="handleComponentConfigUpdate"
            />
          </template>

          <!-- Data source configuration special processing -->
          <template v-else-if="layer.name === 'dataSource'">
            <div class="data-source-config">
              <!-- Configure the component using an existing data source -->
              <!-- üîÑ usev-modelTwo-way binding replaces manual event handling -->
              <component
                :is="layer.component"
                ref="dataSourceConfigRef"
                :model-value="dataSourceConfig"
                :data-sources="componentDataSources"
                :selected-widget-id="selectedWidget?.id"
                :component-id="selectedWidget?.id"
                :component-type="selectedWidget?.type"
                :preview-mode="props.previewMode"
                :global-polling-enabled="props.globalPollingEnabled"
                @request-current-data="handleCurrentDataRequest"
                @update:model-value="(newValue) => {
                  console.log('üî• [ConfigurationPanel] Data source configuration component issues updates:', newValue)
                  if (props.selectedWidget) {
                    dataSourceConfig = newValue
                  }
                }"
              />
            </div>
          </template>

          <!-- Interactive configuration special handling -->
          <template v-else-if="layer.name === 'interaction'">
            <component
              :is="layer.component"
              v-model="interactionConfigList"
              :component-id="selectedWidget?.id"
              :component-type="selectedWidget?.type"
              :readonly="readonly"
              @validate="handleValidation"
              @change="handleInteractionConfigChange"
            />
          </template>

          <!-- Default general processing -->
          <template v-else>
            <component :is="layer.component" v-bind="getLayerProps(layer)" @validate="handleValidation" />
          </template>
        </n-tab-pane>
      </n-tabs>

      <!-- Configuration status information -->
      <div v-if="configurationStatus" class="config-status">
        <n-alert v-if="!configurationStatus.valid" type="error" :title="$t('config.status.error')" size="small">
          <ul v-if="configurationStatus.errors">
            <li v-for="error in configurationStatus.errors" :key="error.field">
              {{ error.field }}: {{ error.message }}
            </li>
          </ul>
        </n-alert>

        <n-alert
          v-else-if="configurationStatus.warnings?.length"
          type="warning"
          :title="$t('config.status.warning')"
          size="small"
        >
          <ul>
            <li v-for="warning in configurationStatus.warnings" :key="warning.field">
              {{ warning.field }}: {{ warning.message }}
            </li>
          </ul>
        </n-alert>
      </div>
    </div>
  </div>
</template>

<script setup lang="ts">
/**
 * V6Configure panel components - Pure data coordinator
 * Simplified configuration panelÔºåpass directlydefinitionand configuration dataÔºåFocus on coordinating data flow
 */

import { ref, reactive, computed, watch, onMounted, onUnmounted, nextTick, inject } from 'vue'
import {
  NTabs,
  NTabPane,
  NForm,
  NFormItem,
  NInputNumber,
  NSwitch,
  NSpace,
  NButton,
  NIcon,
  NDropdown,
  NModal,
  NCard,
  NInput,
  NAlert,
  NEmpty,
  NDivider,
  useMessage
} from 'naive-ui'
import { Settings as SettingsIcon, DocumentOutline } from '@vicons/ionicons5'
import { $t } from '@/locales'
import { smartDeepClone } from '@/utils/deep-clone'

// Import configuration component registration center
import { getVisibleConfigLayers, getConfigLayer } from '@/components/visual-editor/configuration/component-registry'

// Import configuration managers and types
import { configurationIntegrationBridge as configurationManager } from '@/components/visual-editor/configuration/ConfigurationIntegrationBridge'
import { getComponentDataRequirements } from '@/components/visual-editor/core/component-data-requirements'
import type {
  WidgetConfiguration,
  ComponentConfiguration,
  DataSourceConfiguration,
  InteractionConfiguration,
  ValidationResult
} from './types'
import type { VisualEditorWidget } from '@/components/visual-editor/types'

// üî• Import the interaction manager to read the latest status
import { interactionManager } from '@/card2.1/core/interaction-manager'
// üî• Inject editor contextÔºåfor configuration synchronization
const editorContext = inject('editorContext', null) as any

// üîÑ RefactorÔºöRemove direct import executor managerÔºåChange to event communication

interface Props {
  /** selected component */
  selectedWidget: VisualEditorWidget | null
  /** Grid configuration */
  gridConfig?: any
  /** Grid configuration change callback */
  onGridConfigChange?: (config: any) => void
  /** Whether to display the component title */
  showWidgetTitles?: boolean
  /** Switch display title callback */
  onToggleWidgetTitles?: (value: boolean) => void
  /** Whether to read-only mode */
  readonly?: boolean
  /** Whether it is preview mode - Polling function only works in preview mode */
  previewMode?: boolean
  /** Global polling switch - for performance control */
  globalPollingEnabled?: boolean
}

interface Emits {
  (e: 'toggle-widget-titles', value: boolean): void
  (e: 'grid-config-change', config: any): void
  (e: 'multi-data-source-update', widgetId: string, dataSources: Record<string, any>): void
  (e: 'multi-data-source-config-update', widgetId: string, config: any): void
  (e: 'request-current-data', widgetId: string): void
  (
    e: 'data-source-manager-update',
    payload: { componentId: string; componentType: string; config: any; action: string }
  ): void
}

const props = withDefaults(defineProps<Props>(), {
  selectedWidget: null,
  readonly: false,
  previewMode: false,
  globalPollingEnabled: true,
  showWidgetTitles: false
})

const emit = defineEmits<Emits>()

// Message prompt
const message = useMessage()

// Get configuration level definition - Pass in componentIDandwidgetExample to check data source requirements
const configLayers = computed(() => getVisibleConfigLayers(props.selectedWidget?.id, props.selectedWidget))

// Responsive state - Displays the first visible level by default
// üö® Avoid dependencies during initialization computed valueÔºåUse static defaults
const activeTab = ref('base')

// Multiple data source data status
const multiDataSourceData = ref<Record<string, any>>({})

// üîÑ dataMappingConfig has been dataSourceConfig computed replace

// DataSourceConfigForm component reference
const dataSourceFormRef = ref<any>(null)

// DataSourceConfigForm component referenceÔºàExisting systemÔºâ
const dataSourceConfigRef = ref<any>(null)

// Configuration data
const baseConfig = ref({})
// üî• Unified configuration architectureÔºöThe component configuration is changed tocomputedpropertyÔºåSync directly with unified configuration
const componentConfig = computed<ComponentConfiguration>({
  get: () => {
    if (!props.selectedWidget) return { properties: {}, styles: {}, behavior: {}, validation: { required: [], rules: {} } }
    
    // üî• Get component configuration from unified configuration
    const unifiedConfig = props.selectedWidget.metadata?.unifiedConfig
    if (unifiedConfig?.component) {
      return {
        properties: { ...unifiedConfig.component },
        styles: {},
        behavior: {},
        validation: { required: [], rules: {} }
      }
    }
    
    // Falling back to the traditional configuration acquisition method
    const config = configurationManager.getConfiguration(props.selectedWidget.id)
    return {
      properties: config?.component?.properties || {},
      styles: {},
      behavior: {},
      validation: { required: [], rules: {} }
    }
  },
  set: value => {
    if (!props.selectedWidget) return
    
    console.log('üö´ [ConfigurationPanel] Component configuration update disabled - waitCardComponent event communication:', value)
    console.warn('‚ö†Ô∏è [ConfigurationPanel] Component configuration direct editor operations disabled')
    
    // üö´ Disable direct editor manipulation of component configuration
    /*
    const unifiedConfig = props.selectedWidget.metadata?.unifiedConfig || {}
    const updatedUnifiedConfig = {
      ...unifiedConfig,
      component: { ...value.properties }
    }
    
    if (editorContext?.updateNode) {
      editorContext.updateNode(props.selectedWidget.id, {
        properties: value.properties,
        metadata: {
          ...props.selectedWidget.metadata,
          unifiedConfig: updatedUnifiedConfig,
          updatedAt: Date.now()
        }
      })
    }
    */
  }
})

// üî• Unified configuration architectureÔºöThe data source configuration is changed to be synchronized with the unified configuration
const dataSourceConfig = computed<DataSourceConfiguration | null>({
  get: () => {
    if (!props.selectedWidget) return null
    
    // üî• Get data source configuration from unified configuration
    const unifiedConfig = props.selectedWidget.metadata?.unifiedConfig
    if (unifiedConfig?.dataSource) {
      return unifiedConfig.dataSource
    }
    
    // Falling back to the traditional configuration acquisition method
    const config = configurationManager.getConfiguration(props.selectedWidget.id)
    return config?.dataSource || null
  },
  set: value => {
    if (!props.selectedWidget || !value) return
    
    // üî• Update the data source configuration section in unified configuration
    const unifiedConfig = props.selectedWidget.metadata?.unifiedConfig || {}
    const updatedUnifiedConfig = {
      ...unifiedConfig,
      dataSource: {
        // Keep the original typeÔºåNot hardcoded as 'data-source-bindings'
        type: value.type || 'data-source-bindings',
        enabled: true,
        ...value,
        metadata: {
          componentType: props.selectedWidget.type,
          updatedAt: Date.now(),
          source: 'data-source-config-form',
          ...value.metadata
        }
      }
    }
    
    // üö´ Disable direct editor operations - pass insteadCardComponent event communication
    console.log('üî• [ConfigurationPanel] Data source configuration update - Communicate via events:', {
      componentId: props.selectedWidget.id,
      dataSourceConfig: value,
      updatedUnifiedConfig
    })
    
    // TODO: pass insteadCardComponent event emission configuration update
    console.warn('‚ö†Ô∏è [ConfigurationPanel] Direct editor operations disabledÔºåwaitCardComponent event communication implementation')
    
    // üö´ Temporarily disable all direct editor updates
    /*
    if (editorContext?.updateNode) {
      editorContext.updateNode(props.selectedWidget.id, {
        metadata: {
          ...props.selectedWidget.metadata,
          unifiedConfig: updatedUnifiedConfig,
          updatedAt: Date.now()
        }
      })
    }
    */
    
    // üîÑ RefactorÔºöEmit a data source configuration update eventÔºåThe external system is responsible for data execution
    const eventData = {
      componentId: props.selectedWidget.id,
      componentType: props.selectedWidget.type,
      config: value,
      action: 'config-updated'
    }
    emit('data-source-manager-update', eventData)
  }
})

// üî• Unified configuration architectureÔºöThe interaction configuration is changed tocomputedpropertyÔºåSynchronize with unified configuration
const interactionConfig = computed<InteractionConfiguration>({
  get: () => {
    if (!props.selectedWidget) return {}
    
    // üî• Get interaction configuration from unified configuration
    const unifiedConfig = props.selectedWidget.metadata?.unifiedConfig
    if (unifiedConfig?.interaction) {
      return unifiedConfig.interaction
    }
    
    // Falling back to the traditional configuration acquisition method
    const config = configurationManager.getConfiguration(props.selectedWidget.id)
    return config?.interaction || {}
  },
  set: value => {
    if (!props.selectedWidget) return
    
    // üî• Update the interactive configuration section in unified configuration
    const unifiedConfig = props.selectedWidget.metadata?.unifiedConfig || {}
    const updatedUnifiedConfig = {
      ...unifiedConfig,
      interaction: { ...value }
    }
    
    // Sync to editor context
    if (editorContext?.updateNode) {
      editorContext.updateNode(props.selectedWidget.id, {
        metadata: {
          ...props.selectedWidget.metadata,
          unifiedConfig: updatedUnifiedConfig,
          updatedAt: Date.now()
        }
      })
    }
  }
})

// configuration status
const configurationStatus = ref<ValidationResult | null>(null)

// Computed properties
const interactionConfigList = computed({
  get: () => {
    // from interactionConfig extracted from configs arrayÔºåIf not, return an empty array
    return interactionConfig.value.configs || []
  },
  set: newConfigs => {
    // Store the configuration array into interactionConfig middle
    interactionConfig.value = {
      ...interactionConfig.value,
      configs: newConfigs,
      enabled: true,
      metadata: {
        ...interactionConfig.value.metadata,
        updatedAt: Date.now()
      }
    }
  }
})
const widgetDisplayName = computed(() => {
  if (!props.selectedWidget) return ''
  return props.selectedWidget.metadata?.card2Definition?.name || props.selectedWidget.type || 'Unknown Component'
})

// V6: Get component definition - Obtained directly from component metadata
const componentDefinition = computed(() => {
  if (!props.selectedWidget) return null

  // V6: Prioritize fromCard2.1Component metadata acquisition definition
  const card2Definition = props.selectedWidget.metadata?.card2Definition
  if (card2Definition) {
    return card2Definition
  }

  // Falling back to traditional methods of obtaining data requirements
  return getComponentDataRequirements(props.selectedWidget.type)
})

// Component data source information - Adapt to existing DataSourceConfigForm data format
const componentDataSources = computed(() => {
  const definition = componentDefinition.value

  // üî• repairÔºödeal with Card2.1 component dataRequirements Format
  if (definition?.dataRequirements) {
    // üî• Handle multiple data sourcesÔºöfor each dataFields Create an independent data source configuration
    if (definition.dataRequirements.dataFields && Array.isArray(definition.dataRequirements.dataFields)) {
      return definition.dataRequirements.dataFields.map((field: any) => {
        // Create field mapping for each data field
        const fieldMappings: Record<string, any> = {
          [field.name]: {
            path: field.name,
            type: field.type,
            description: field.description || '',
            required: field.required || false
          }
        }

        // If there is sample dataÔºåAdd to field mapping
        if (field.example) {
          fieldMappings[field.name].example = field.example
        }

        return {
          key: field.name, // Use field name askeyÔºàlike dataSource1, dataSource2Ôºâ
          name: field.description || field.name, // Use description as display name
          type: field.type || 'object',
          fieldsToMap: [
            {
              key: field.name,
              targetProperty: field.type || 'object'
            }
          ],
          fieldMappings,
          expectedDataFormat: field.type || 'object',
          validationRules: {},
          description: field.description || `${field.name} ${$t('visualEditor.dataSource')}`,
          example: field.example // Pass sample data
        }
      })
    }

    // üî• rollbackÔºöWorking with single data source formatsÔºàuse primaryDataÔºâ
    if (definition.dataRequirements.primaryData) {
      const primaryData = definition.dataRequirements.primaryData
      const fieldMappings: Record<string, any> = {
        [primaryData.name]: {
          path: primaryData.name,
          type: primaryData.type,
          description: primaryData.description || '',
          required: primaryData.required || false
        }
      }

      return [
        {
          key: primaryData.name || 'main',
          name: primaryData.description || primaryData.name || 'master data source',
          type: primaryData.type || 'object',
          fieldsToMap: [
            {
              key: primaryData.name,
              targetProperty: primaryData.type || 'object'
            }
          ],
          fieldMappings,
          expectedDataFormat: primaryData.type || 'object',
          validationRules: {},
          description: primaryData.description || 'The component's primary data source'
        }
      ]
    }

    // üî• final rollbackÔºöCompatible with older formats (fields/primary)
    const fieldsToMap = definition.dataRequirements.fields?.map((field: any) => ({
      key: field.name,
      targetProperty: field.type || 'string'
    })) || [
      { key: 'value', targetProperty: 'string' },
      { key: 'label', targetProperty: 'string' },
      { key: 'status', targetProperty: 'string' }
    ]
    const fieldMappings: Record<string, any> = {}

    // Build field mapping
    definition.dataRequirements.fields?.forEach((field: any) => {
      fieldMappings[field.name] = {
        path: field.name,
        type: field.type,
        description: field.description || '',
        required: field.required || false
      }
    })

    return [
      {
        key: 'main',
        name: definition.dataRequirements.primary?.name || 'master data source',
        type: definition.dataRequirements.primary?.type || 'object',
        fieldsToMap,
        fieldMappings,
        expectedDataFormat: definition.dataRequirements.primary?.type || 'object',
        validationRules: {},
        description: definition.dataRequirements.primary?.description || 'The component's primary data source'
      }
    ]
  }

  // üî• processing standard dataSources Format
  if (definition?.dataSources) {
    return definition.dataSources.map((dataSource: any) => ({
      key: dataSource.key || dataSource.name,
      name: dataSource.name,
      type: dataSource.type || 'unknown',
      fieldsToMap: dataSource.fieldsToMap || [],
      fieldMappings: dataSource.fieldMappings || {},
      expectedDataFormat: dataSource.expectedDataFormat,
      validationRules: dataSource.validationRules || {},
      // üî• repairÔºöPass the original data source objectÔºåContains all sample data
      originalData: dataSource
    }))
  }

  // üî• If not foundÔºåProvide default configuration
  return [
    {
      key: 'main',
      name: $t('visualEditor.primaryDataSource'),
      type: 'object',
      fieldsToMap: ['value', 'label', 'status', 'timestamp'],
      fieldMappings: {
        value: { path: 'value', type: 'number', description: $t('visualEditor.dataValue') },
        label: { path: 'label', type: 'string', description: $t('visualEditor.dataLabel') },
        status: { path: 'status', type: 'string', description: $t('visualEditor.dataStatus') },
        timestamp: { path: 'timestamp', type: 'string', description: $t('visualEditor.dataTimestamp') }
      },
      expectedDataFormat: 'object',
      validationRules: {},
      description: $t('visualEditor.componentDataSource') + 'Ôºå' + $t('visualEditor.supportVariousFormats')
    }
  ]
})

// Enhanced data source information - Contains complete component definition informationÔºàStay backwards compatibleÔºâ
const enrichedDataSources = computed(() => {
  // üî• repairÔºöuse componentDataSources the resultÔºåensure consistency
  const basicDataSources = componentDataSources.value

  if (!basicDataSources || basicDataSources.length === 0) {
    return []
  }

  return basicDataSources.map(dataSource => ({
    ...dataSource,
    // Pass complete field mapping rules
    fieldMappings: dataSource.fieldMappings || {},
    // Extract sample data from component definition
    exampleData: extractExampleDataFromDefinition(dataSource),
    // Data processing scriptÔºàif there isÔºâ
    dataProcessScript: dataSource.dataProcessScript || '',
    // Pass label information
    label: dataSource.name || dataSource.key
  }))
})

/**
 * Extract sample data from component definition
 * üî• unified standardsÔºöonly use example FieldÔºåEnsure consistent sample data standards across components
 */
function extractExampleDataFromDefinition(dataSource: any) {
  // 1. from fieldMappings of defaultValue Build sample data
  if (dataSource.fieldMappings) {
    const exampleFromMappings: Record<string, any> = {}
    let hasDefaults = false

    Object.entries(dataSource.fieldMappings).forEach(([sourceKey, mapping]: [string, any]) => {
      if (mapping.defaultValue !== undefined) {
        exampleFromMappings[sourceKey] = mapping.defaultValue
        hasDefaults = true
      }
    })

    if (hasDefaults) {
      return exampleFromMappings
    }
  }

  // 2. üî• unified standardsÔºöCheck only example Field
  if (dataSource.originalData?.example) {
    return dataSource.originalData.example
  }

  // 3. Check test data in component metadata
  if (componentDefinition.value?.metadata?.testData) {
    const testData = componentDefinition.value.metadata.testData[dataSource.key]
    if (testData) {
      return testData
    }
  }

  // 4. Use common default data
  return null // return nullÔºålet DataSourceConfigForm Use your own default data generation logic
}

// Configure change listener cleanup function
let configChangeCleanup: (() => void) | null = null

// üî• repairÔºöEnhance anti-circulation mechanismÔºåUse multiple protections
let isUpdatingFromManager = false
let lastSyncTime = 0
let lastSyncConfig: string | null = null

// Monitor configuration changes and synchronize toConfigurationManager
// üö® NoticeÔºödataSourceConfig excludedÔºåbecause it has its own computed setter processing mechanism
watch(
  [baseConfig, componentConfig, interactionConfig],
  () => {
    // Multiple checks to prevent cyclic updates
    if (!props.selectedWidget || isUpdatingFromManager) {
      return
    }

    // üî• NewÔºöAnti-shake mechanismÔºåAvoid repeated synchronization in a short period of time
    const now = Date.now()
    if (now - lastSyncTime < 100) {
      return
    }

    // üî• NewÔºöContent deduplicationÔºåAvoid repeated synchronization of the same configuration
    const currentConfig = JSON.stringify({
      base: baseConfig.value,
      component: componentConfig.value,
      interaction: interactionConfig.value
    })

    if (currentConfig === lastSyncConfig) {
      return
    }
    lastSyncTime = now
    lastSyncConfig = currentConfig
    syncConfigurationToManager()
  },
  { deep: true }
)

// üîÑ V6The listener has been dataSourceConfig computed Responsive system replacement

// üî• NewÔºöExecutor data update callback cleanup function
let executorDataUpdateCleanup: (() => void) | null = null

// life cycle
onMounted(() => {
  // üîÑ RefactorÔºöRemove direct executor listenerÔºåData updates are handled through the event mechanism
  // Data updates will be viaPanelEditorevent system deliveryÔºåDon‚Äôt listen directly here
})

onUnmounted(() => {
  if (configChangeCleanup) {
    configChangeCleanup()
  }

  // üî• NewÔºöCleanup executor data update callback
  if (executorDataUpdateCleanup) {
    executorDataUpdateCleanup()
  }
})

// Method implementation

/**
 * Load component configuration
 */
const loadWidgetConfiguration = async (widgetId: string) => {
  // Set anti-loop flag
  isUpdatingFromManager = true

  try {
    let config = configurationManager.getConfiguration(widgetId)

    if (!config) {
      // Initialize default configuration
      configurationManager.initializeConfiguration(widgetId)
      config = configurationManager.getConfiguration(widgetId)
    }

    if (config) {
      // üîß Now load the configuration for all levels
      baseConfig.value = { ...config.base }

      // üî• critical fixÔºöPrioritize from InteractionManager Get the latest component status
      const latestInteractionState = interactionManager.getLatestComponentState(widgetId)

      // Merge the configuration manager's configuration and the latest status of the interaction manager
      const mergedComponentConfig = {
        ...config.component,
        properties: {
          ...config.component.properties,
          // Extract key attributes from interaction state
          ...(latestInteractionState.deviceId !== undefined && { deviceId: latestInteractionState.deviceId }),
          ...(latestInteractionState.metricsList !== undefined && { metricsList: latestInteractionState.metricsList }),
          // deal with customize object
          customize: {
            ...config.component.properties?.customize,
            ...(latestInteractionState.title !== undefined && { title: latestInteractionState.title }),
            ...(latestInteractionState.content !== undefined && { content: latestInteractionState.content }),
            ...(latestInteractionState.themeColor !== undefined && { themeColor: latestInteractionState.themeColor }),
            ...(latestInteractionState.fontSize !== undefined && { fontSize: latestInteractionState.fontSize })
          }
        },
        styles: {
          ...config.component.styles,
          // Extract style properties from interaction state
          ...(latestInteractionState.backgroundColor !== undefined && {
            backgroundColor: latestInteractionState.backgroundColor
          }),
          ...(latestInteractionState.textColor !== undefined && { color: latestInteractionState.textColor }),
          ...(latestInteractionState.borderColor !== undefined && { borderColor: latestInteractionState.borderColor }),
          ...(latestInteractionState.opacity !== undefined && { opacity: latestInteractionState.opacity }),
          ...(latestInteractionState.visibility !== undefined && { visibility: latestInteractionState.visibility })
        }
      }

      componentConfig.value = mergedComponentConfig

      // üö® Not set directly dataSourceConfigÔºåbecause it is computed property
      // dataSourceConfig will pass getter automatically from ConfigurationManager Get the latest value
      interactionConfig.value = { ...config.interaction }

      // üîÑ RefactorÔºöIf you have a saved data source configurationÔºåPerform data retrieval via event notification
      if (config.dataSource?.config && Object.keys(config.dataSource.config).length > 0) {
        // Send an event toPanelEditorprocessing data execution
        emit('data-source-manager-update', {
          componentId: widgetId,
          componentType: props.selectedWidget?.type || '',
          config: config.dataSource.config,
          action: 'config-restored'
        })
      }

      if (process.env.NODE_ENV === 'development') {
      }
    }
  } catch (error) {
    message.error($t('visualEditor.configLoadFailed'))
    console.error('Configuration load failed:', error)
  } finally {
    // üî• repairÔºöDelayed reset of anti-loop flagsÔºåmake sureVueResponsive update completed
    nextTick(() => {
      setTimeout(() => {
        isUpdatingFromManager = false
      }, 50) // 50msDelay ensures all responsive updates complete
    })
  }
}

/**
 * processing fromConfigurationManagerconfiguration changes
 */
const handleConfigurationChange = (config: WidgetConfiguration) => {
  // Set anti-loop flag
  isUpdatingFromManager = true

  try {
    // Update local configuration status
    // üîß Now load the configuration for all levels
    baseConfig.value = { ...config.base }
    componentConfig.value = { ...config.component }
    // dataSourceConfig yes computed propertyÔºåwill automatically pass getter from ConfigurationManager Get
    // No manual settings requiredÔºödataSourceConfig.value = config.dataSource ? { ...config.dataSource } : null
    interactionConfig.value = { ...config.interaction }

    // V6: The data source is configured bydataSourceConfig computedProperty management
    // dataMappingConfigRemovedÔºåConfiguration passeddataSourceConfig.valuedeal with
  } finally {
    // üî• repairÔºöDelayed reset of anti-loop flagsÔºåmake sureVueResponsive update completed
    nextTick(() => {
      setTimeout(() => {
        isUpdatingFromManager = false
      }, 50) // 50msDelay ensures all responsive updates complete
    })
  }
}

/**
 * Synchronize local configuration toConfigurationManager
 */
const syncConfigurationToManager = async () => {
  if (!props.selectedWidget) return

  try {
    const config: WidgetConfiguration = {
      base: { ...baseConfig.value }, // üîß now containsbaseConfiguration
      component: { ...componentConfig.value },
      dataSource: dataSourceConfig.value ? { ...dataSourceConfig.value } : {},
      interaction: { ...interactionConfig.value },
      metadata: {
        version: '1.0.0',
        createdAt: Date.now(),
        updatedAt: Date.now()
      }
    }

    configurationManager.setConfiguration(props.selectedWidget.id, config)
  } catch (error) {}
}

/**
 * Reset local configuration
 */
const resetLocalConfiguration = () => {
  // üîß Reset all configuration levels
  baseConfig.value = {}
  componentConfig.value = {
    properties: {},
    styles: {},
    behavior: {},
    validation: { required: [], rules: {} }
  }

  dataSourceConfig.value = null
  interactionConfig.value = { configs: [], enabled: true }
  configurationStatus.value = null

  // V6: Data source configuration reset bydataSourceConfig computedAttribute handling
  // dataMappingConfigRemoved
}

/**
 * Handle verification results
 */
const handleValidation = (result: ValidationResult) => {
  configurationStatus.value = result
}

/**
 * Handle data updates from multiple data sources
 */
const handleDataSourceUpdate = (data: Record<string, any>) => {
  // Update local data status
  multiDataSourceData.value = { ...data }

  // Emit events to the parent componentÔºåpassed to the actual component
  if (props.selectedWidget) {
    emit('multi-data-source-update', props.selectedWidget.id, data)
  }
}

/**
 * Handling dynamic data source updates
 */
const handleDynamicDataSourceUpdate = (key: string, data: any) => {
  // Update local data status
  multiDataSourceData.value = {
    ...multiDataSourceData.value,
    [key]: data
  }

  // Update simultaneously ConfigurationManager Data source configuration in
  if (props.selectedWidget) {
    // Create a match Card2Wrapper expected data structure
    const dataSourceBindings: Record<string, any> = {}

    // Pack the data from each data source into Card2Wrapper expected format
    Object.entries(multiDataSourceData.value).forEach(([dataSourceKey, data]) => {
      dataSourceBindings[dataSourceKey] = {
        rawData: JSON.stringify(data), // Card2Wrapper expected rawData Field
        fieldMappings: {}, // Field mappingÔºàTemporarily emptyÔºâ
        filterPath: '' // filter pathÔºàTemporarily emptyÔºåSubsequent expansionÔºâ
      }
    })

    // Create or update data source configuration
    const dataSourceConfig: DataSourceConfiguration = {
      type: 'data-source-bindings',
      enabled: true,
      config: {
        dataSourceBindings
      },
      metadata: {
        updatedAt: Date.now()
      }
    }

    // renew ConfigurationManager
    configurationManager.updateConfiguration(props.selectedWidget.id, 'dataSource', dataSourceConfig)

    // Emit events to the parent component
    emit('multi-data-source-update', props.selectedWidget.id, multiDataSourceData.value)
  }
}

/**
 * Get initial data source valueÔºàRestore from saved configurationÔºâ
 */
const getInitialDataSourceValues = () => {
  if (!props.selectedWidget) {
    return {}
  }

  const config = configurationManager.getConfiguration(props.selectedWidget.id)
  const initialData: Record<string, string> = {}

  if (config?.dataSource?.type === 'data-source-bindings' && config.dataSource.config?.dataSourceBindings) {
    Object.entries(config.dataSource.config.dataSourceBindings).forEach(([key, binding]: [string, any]) => {
      if (binding.rawData) {
        initialData[key] = binding.rawData // Directly use the saved JSON string
      }
    })
  }
  return initialData
}

// üîÑ handleDataSourceConfigUpdate has been dataSourceConfig computed setter replace

/**
 * processing from EditorDataSourceConfig configuration updateÔºàStay backwards compatibleÔºâ
 */
const handleEditorDataSourceUpdate = (config: any) => {
  // Redirect to new handling method
  handleDataSourceConfigUpdate(config)
}

/**
 * Handle current data request - üî• Provide runtime data to the configuration panel
 */
const handleCurrentDataRequest = (widgetId: string) => {
  // Request parent componentÔºàPanelEditorÔºâProvide current runtime data
  emit('request-current-data', widgetId)
}

// üîÑ getDataSourceEventListeners has been v-model and reactive systems

// V6: RemovehandleDataMappingConfigUpdate - Automatic processing of data changes

// V6: RemovehandlePreviewUpdate - SimpleDataMappingFormInternal processing preview

/**
 * deal withBaseConfigure application
 */
const handleBaseConfigApply = (config: any) => {
  if (props.selectedWidget) {
    configurationManager.updateConfiguration(props.selectedWidget.id, 'base', config)
  }
}

/**
 * Handle component configuration updates - Performance optimizationÔºöAnti-shake batch update + Reduce logging
 */
let componentConfigUpdateTimer: number | null = null
let isConfigUpdating = false
const handleComponentConfigUpdate = (config: any) => {
  if (!props.selectedWidget?.id || isConfigUpdating) return

  // Update nowWidget propertiesto get instant feedback
  if (props.selectedWidget.metadata?.isCard2Component && props.selectedWidget.properties) {
    Object.assign(props.selectedWidget.properties, config)
  }

  // Image stabilization saved toconfigurationManager
  if (componentConfigUpdateTimer) {
    clearTimeout(componentConfigUpdateTimer)
  }

  componentConfigUpdateTimer = window.setTimeout(() => {
    isConfigUpdating = true

    try {
      if (props.selectedWidget.metadata?.isCard2Component) {
        // Update component configuration hierarchy
        configurationManager.updateConfiguration(props.selectedWidget.id, 'component', {
          properties: config,
          styles: {},
          behavior: {},
          validation: { required: [], rules: {} }
        })
      } else {
        // Traditional component configuration saving
        configurationManager.updateConfiguration(props.selectedWidget.id, 'component', config)
      }
    } catch (error) {
    } finally {
      isConfigUpdating = false
      componentConfigUpdateTimer = null
    }
  }, 300) // increase to300msAnti-shakeÔºåBe consistent with the configuration form
}

/**
 * Handling interactive configuration updates
 */
const handleInteractionConfigChange = (configs: any[]) => {
  if (!props.selectedWidget?.id) return

  // via computed propertiessetterAutomatically update local interaction configuration
  interactionConfigList.value = configs

  // Save to configuration manager - Now pass the complete interaction configuration object
  configurationManager.updateConfiguration(props.selectedWidget.id, 'interaction', interactionConfig.value)
}

/**
 * deal withBaseConfiguration reset
 */
const handleBaseConfigReset = () => {
  baseConfig.value = {}
}

/**
 * get hierarchicalprops
 */
const getLayerProps = (layer: any) => {
  const commonProps = {
    readonly: props.readonly
  }

  switch (layer.name) {
    case 'base':
      return {
        ...commonProps,
        modelValue: baseConfig.value,
        nodeId: props.selectedWidget?.id || ''
      }
    case 'component':
      return {
        ...commonProps,
        modelValue: componentConfig.value.properties || {},
        widget: props.selectedWidget
      }
    case 'dataSource':
      return {
        ...commonProps,
        selectedWidgetId: props.selectedWidget?.id || '',
        componentType: props.selectedWidget?.type,
        dataSources: enrichedDataSources.value,
        modelValue: dataSourceConfig.value
      }
    case 'interaction':
      return {
        ...commonProps,
        modelValue: interactionConfig.value,
        widget: props.selectedWidget
      }
    default:
      return commonProps
  }
}

/**
 * Handling grid configuration changes
 */
const handleGridConfigChange = () => {
  if (props.gridConfig) {
    // Prioritize event emission
    emit('grid-config-change', props.gridConfig)
    // Compatible attribute callback
    if (props.onGridConfigChange) {
      props.onGridConfigChange(props.gridConfig)
    }
  }
}

/**
 * Toggle display title
 */
const onToggleWidgetTitles = (value: boolean) => {
  // Prioritize event emission
  emit('toggle-widget-titles', value)
  // Compatible attribute callback
  if (props.onToggleWidgetTitles) {
    props.onToggleWidgetTitles(value)
  }
}

// Monitor changes in selected components - Executed after all function definitions
watch(
  () => props.selectedWidget,
  async (newWidget, oldWidget) => {
    if (newWidget?.id === oldWidget?.id) return

    // Clean up old listeners
    if (configChangeCleanup) {
      configChangeCleanup()
      configChangeCleanup = null
    }

    if (newWidget) {
      await loadWidgetConfiguration(newWidget.id)

      // Listen for configuration changes
      configChangeCleanup = configurationManager.onConfigurationChange(newWidget.id, handleConfigurationChange)
    } else {
      // Clear configuration
      resetLocalConfiguration()
    }
  },
  { immediate: true }
)

// üî• monitor configLayers changeÔºåmake sure activeTab Point to a valid tab
watch(
  configLayers,
  newLayers => {
    if (newLayers.length > 0) {
      // If currently activeTab Not in the new level listÔºåSwitch to the first available
      const currentTabExists = newLayers.some(layer => layer.name === activeTab.value)
      if (!currentTabExists) {
        activeTab.value = newLayers[0].name
      }
    }
  },
  { immediate: true }
)

// üö® Removed configuration reloading when switching tabsÔºåAvoid circular dependencies
// Loading of configuration should be triggered by component selection changeÔºåInstead of tab switching
</script>

<style scoped>
.configuration-panel {
  height: 100%;
  display: flex;
  flex-direction: column;
}

.global-settings,
.widget-configuration {
  flex: 1;
  overflow: hidden;
  display: flex;
  flex-direction: column;
}

.panel-title {
  font-size: 14px;
  font-weight: 600;
  margin: 0 0 16px 0;
  color: var(--text-color);
}

.global-form {
  padding: 0 8px;
}

.grid-config-item {
  display: flex;
  align-items: center;
  justify-content: space-between;
  font-size: 12px;
}

.config-header {
  display: flex;
  align-items: center;
  justify-content: space-between;
  padding: 8px;
  border-bottom: 1px solid var(--border-color);
}

.header-actions {
  display: flex;
  align-items: center;
  gap: 8px;
}

.config-tabs {
  flex: 1;
  overflow: hidden;
}

.config-tabs :deep(.n-tabs-content) {
  height: calc(100% - 32px);
  overflow: hidden;
  padding: 0;
}

/* Add only for specific configuration typespadding */
.config-tabs :deep(.n-tab-pane) {
  height: 100%;
}

/* Basic configuration and other needspaddingconfiguration */
.config-tabs :deep(.n-tab-pane:not([name='component'])) {
  padding: 8px;
  overflow-y: auto;
}

/* Component configuration takes up all spaceÔºåunnecessarypadding */
.config-tabs :deep(.n-tab-pane[name='component']) {
  padding: 0;
  height: 100%;
  overflow: hidden;
}

.config-status {
  padding: 8px;
  border-top: 1px solid var(--border-color);
}

.config-json {
  font-family: 'Monaco', 'Menlo', 'Ubuntu Mono', monospace;
  font-size: 12px;
}

/* Scroll bar style */
.config-tabs :deep(.n-tabs-content)::-webkit-scrollbar {
  width: 6px;
}

.config-tabs :deep(.n-tabs-content)::-webkit-scrollbar-track {
  background: #f1f1f1;
  border-radius: 3px;
}

.config-tabs :deep(.n-tabs-content)::-webkit-scrollbar-thumb {
  background: #c1c1c1;
  border-radius: 3px;
}

.config-tabs :deep(.n-tabs-content)::-webkit-scrollbar-thumb:hover {
  background: #a8a8a8;
}

/* Responsive adjustments */
@media (max-width: 768px) {
  .config-header {
    flex-direction: column;
    align-items: flex-start;
    gap: 8px;
  }

  .header-actions {
    width: 100%;
    justify-content: flex-end;
  }

  .grid-config-item {
    flex-direction: column;
    align-items: flex-start;
    gap: 4px;
  }
}

/* V6style - Simplified data configuration area */
.v6-data-config {
  display: flex;
  flex-direction: column;
  gap: 16px;
}

.v6-data-mapping {
  padding: 4px;
}

.no-data-source-hint {
  padding: 8px;
}

/* Data source configuration style */
.data-source-config {
  height: 100%;
  overflow: hidden;
  display: flex;
  flex-direction: column;
}

.data-source-config :deep(.n-scrollbar) {
  flex: 1;
}

.data-source-config :deep(.n-scrollbar-content) {
  padding: 8px;
  min-height: 100%;
}
</style>
