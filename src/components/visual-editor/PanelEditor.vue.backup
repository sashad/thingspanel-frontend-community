<script setup lang="ts">
import { computed, nextTick, onMounted, onUnmounted, provide, ref, toRaw, watch } from 'vue'
import { smartDeepClone } from '@/utils/deep-clone'
import { useDialog, useMessage, NDrawer, NDrawerContent } from 'naive-ui'
import { useFullscreen } from '@vueuse/core'
import { useAppStore } from '@/store/modules/app'
import FullScreen from '@/components/common/full-screen.vue'
import { $t } from '@/locales'
import { getBoard, PutBoard } from '@/service/api'
import { VisualEditorToolbar } from './components/toolbar'
import WidgetLibrary from './components/WidgetLibrary/WidgetLibrary.vue'
import { initializeSettings } from '@/core/interaction-system'
import ConfigurationPanel from './configuration/ConfigurationPanel.vue'
import { configurationIntegrationBridge as configurationManager } from './configuration/ConfigurationIntegrationBridge'
import { CanvasRenderer, GridstackRenderer } from './renderers'
import { createEditor } from './hooks'
import { usePreviewMode } from './hooks/usePreviewMode'
import { usePanelConfigManager } from './hooks/usePanelConfigManager'
import { usePanelDataManager } from './hooks/usePanelDataManager'
import { usePanelPollingManager } from './hooks/usePanelPollingManager'
import { usePanelEventHandler } from './hooks/usePanelEventHandler'
import { usePanelLifecycleManager } from './hooks/usePanelLifecycleManager'
import PollingController from './components/PollingController.vue'
import type { RendererType, VisualEditorWidget, GraphData } from './types'

// Import data source registration
// import './data-sources' // Temporary notesÔºåFile does not exist

import { useComponentTree } from '@/card2.1/hooks'
import { visualEditorLogger } from '@/utils/logger'
// üî• Polling system import
import { useGlobalPollingManager } from './core/GlobalPollingManager'
import { editorDataSourceManager } from './core/EditorDataSourceManager'
import { interactionManager } from '@/card2.1/core/interaction-manager'

// üî• supplyEditorDataSourceManagerto child component
provide('editorDataSourceManager', editorDataSourceManager)

// üî• Component Executor Registry
const componentExecutorRegistry = ref(new Map<string, () => Promise<void>>())
provide('componentExecutorRegistry', componentExecutorRegistry.value)

// üî• Pass the component executor registry toEditorDataSourceManager
editorDataSourceManager.setComponentExecutorRegistry(componentExecutorRegistry.value)

// initialization Card 2.1 integrated
useComponentTree({
  autoInit: true,
  enableI18n: true
})

// Initialization settings panel
initializeSettings()

const dialog = useDialog()
const message = useMessage()
const appStore = useAppStore()

const props = defineProps<{
  panelId: string
  /**
   * Whether to display the toolbar
   * Default is trueÔºåStay backwards compatible
   */
  showToolbar?: boolean
  /**
   * Whether to display the page title bar
   * Default is trueÔºåStay backwards compatible
   */
  showPageHeader?: boolean
}>()

const emit = defineEmits<{
  'state-manager-ready': [stateManager: any]
}>()

// Status management
const fullui = ref()
const isEditing = ref(false) // Default preview mode
const isSaving = ref(false)

// üî• Performance optimizationÔºöstate cache
const stateCache = ref<{
  lastGetState?: any
  lastSetState?: any
  lastStateHash?: string
  cacheTime?: number
}>({})
const STATE_CACHE_DURATION = 5000 // 5second cache
const hasChanges = ref(false)
const isUnmounted = ref(false)

// The code related to interactive testing has been migrated to visual-editor-details/index.vue

// Editor status
const currentRenderer = ref<RendererType>('gridstack')

// drawer status - initial stateÔºöpreview modeÔºåDrawer closed
const showLeftDrawer = ref(false) // Left component library drawer
const showRightDrawer = ref(false) // Right properties panel drawer

// Drag and drop state management
const isDragging = ref(false)
const draggedComponent = ref<string | null>(null)
const selectedNodeId = ref<string>('')
const showWidgetTitles = ref(true) // main switchÔºåShow title by default

// Multiple data sources data storage - with componentsIDas key
const multiDataSourceStore = ref<Record<string, Record<string, any>>>({})

// Multiple data source configuration storage - with componentsIDas keyÔºåStore complete configuration information
const multiDataSourceConfigStore = ref<Record<string, any>>({})

// Poll manager instance
const pollingManager = useGlobalPollingManager()

// Global polling switch status and processing functions have been migrated to usePanelPollingManager

// Full screen functionality
const { isFullscreen, toggle } = useFullscreen(fullui)

// Create editor context
const editorContext = createEditor()
const { stateManager, addWidget, selectNode, updateNode } = editorContext
const { setPreviewMode, isPreviewMode } = usePreviewMode()

// üî• Configuration management combined functions
const { parseConfig, validateConfig, migrateConfig, getDefaultConfig, analyzeCloneability } = usePanelConfigManager()

// üî• Data management combined functions
const dataManagerDependencies = {
  stateManager,
  configurationManager,
  multiDataSourceConfigStore,
  isUnmounted
}
const {
  panelData: panelDataFromManager,
  dataFetched: dataFetchedFromManager,
  editorConfig: editorConfigFromManager,
  preEditorConfig: preEditorConfigFromManager,
  setState: setStateFromManager,
  getState: getStateFromManager,
  fetchBoard: fetchBoardFromManager,
  initializePanelData: initializePanelDataFromManager
} = usePanelDataManager(props, dataManagerDependencies)

// üî• Poll management combined functions
const pollingManagerDependencies = {
  pollingManager,
  stateManager,
  configurationManager,
  editorDataSourceManager
}
const {
  globalPollingEnabled: globalPollingEnabledFromManager,
  pollingStats: pollingStatsFromManager,
  initializePollingTasksAndEnable: initializePollingTasksAndEnableFromManager,
  handlePollingToggle: handlePollingToggleFromManager,
  handlePollingEnabled: handlePollingEnabledFromManager,
  handlePollingDisabled: handlePollingDisabledFromManager
} = usePanelPollingManager(pollingManagerDependencies)

// Using state variables from the data managerÔºàReplace the originalÔºâ
const panelData = panelDataFromManager
const dataFetched = dataFetchedFromManager
const editorConfig = editorConfigFromManager
const preEditorConfig = preEditorConfigFromManager

// Using functions from the data manager
const setState = setStateFromManager
const getState = getStateFromManager
const fetchBoard = fetchBoardFromManager
const initializePanelData = initializePanelDataFromManager

// Using status and functions from the polling manager
const globalPollingEnabled = globalPollingEnabledFromManager
const pollingStats = pollingStatsFromManager
const initializePollingTasksAndEnable = initializePollingTasksAndEnableFromManager
const handlePollingToggle = handlePollingToggleFromManager
const handlePollingEnabled = handlePollingEnabledFromManager
const handlePollingDisabled = handlePollingDisabledFromManager

// üî• Event handling combined functions
const eventHandlerDependencies = {
  // Status management
  showLeftDrawer,
  showRightDrawer,
  isDragging,
  draggedComponent,
  currentRenderer,
  showWidgetTitles,
  hasChanges,
  multiDataSourceStore,
  multiDataSourceConfigStore,
  selectedNodeId,

  // Configuration management
  editorConfig,
  panelData,

  // Editor features
  stateManager,
  addWidget,
  setState,
  getState,
  getDefaultConfig,
  selectNode,
  editorDataSourceManager
}
const {
  // Drawer control
  handleToggleLeftDrawer: handleToggleLeftDrawerFromHandler,
  handleToggleRightDrawer: handleToggleRightDrawerFromHandler,

  // Drag and drop processing
  handleDragStart: handleDragStartFromHandler,
  handleDragEnd: handleDragEndFromHandler,

  // Renderers and view controls
  handleRendererChange: handleRendererChangeFromHandler,
  handleToggleWidgetTitles: handleToggleWidgetTitlesFromHandler,

  // Component operations
  handleAddWidget: handleAddWidgetFromHandler,
  handleClearAll: handleClearAllFromHandler,

  // Import and export
  handleImportConfig: handleImportConfigFromHandler,
  handleExportConfig: handleExportConfigFromHandler,

  // Configuration changes
  handleGridConfigChange: handleGridConfigChangeFromHandler,
  handleGridstackConfigChange: handleGridstackConfigChangeFromHandler,
  handleCanvasConfigChange: handleCanvasConfigChangeFromHandler,

  // Data source processing
  handleMultiDataSourceUpdate: handleMultiDataSourceUpdateFromHandler,
  handleMultiDataSourceConfigUpdate: handleMultiDataSourceConfigUpdateFromHandler,

  // Canvas operation control
  handleZoomIn: handleZoomInFromHandler,
  handleZoomOut: handleZoomOutFromHandler,
  handleResetZoom: handleResetZoomFromHandler,
  handleUndo: handleUndoFromHandler,
  handleRedo: handleRedoFromHandler,

  // Renderer event handling
  handleRendererReady: handleRendererReadyFromHandler,
  handleRendererError: handleRendererErrorFromHandler,

  // Node selection and interaction
  handleNodeSelect: handleNodeSelectFromHandler,
  handleRequestSettings: handleRequestSettingsFromHandler,
  handleCanvasClick: handleCanvasClickFromHandler,

  // Component life cycle events
  handleComponentAdded: handleComponentAddedFromHandler,
  handleComponentRemoved: handleComponentRemovedFromHandler,
  handleComponentConfigChanged: handleComponentConfigChangedFromHandler
} = usePanelEventHandler(props, eventHandlerDependencies)

// Using functions from event handlers
const handleToggleLeftDrawer = handleToggleLeftDrawerFromHandler
const handleToggleRightDrawer = handleToggleRightDrawerFromHandler
const handleDragStart = handleDragStartFromHandler
const handleDragEnd = handleDragEndFromHandler
const handleRendererChange = handleRendererChangeFromHandler
const handleToggleWidgetTitles = handleToggleWidgetTitlesFromHandler
const handleAddWidget = handleAddWidgetFromHandler
const handleClearAll = handleClearAllFromHandler
const handleImportConfig = handleImportConfigFromHandler
const handleExportConfig = handleExportConfigFromHandler
const handleGridConfigChange = handleGridConfigChangeFromHandler
const handleGridstackConfigChange = handleGridstackConfigChangeFromHandler
const handleCanvasConfigChange = handleCanvasConfigChangeFromHandler
const handleMultiDataSourceUpdate = handleMultiDataSourceUpdateFromHandler
const handleMultiDataSourceConfigUpdate = handleMultiDataSourceConfigUpdateFromHandler
const handleZoomIn = handleZoomInFromHandler
const handleZoomOut = handleZoomOutFromHandler
const handleResetZoom = handleResetZoomFromHandler
const handleUndo = handleUndoFromHandler
const handleRedo = handleRedoFromHandler
const handleRendererReady = handleRendererReadyFromHandler
const handleRendererError = handleRendererErrorFromHandler
const handleNodeSelect = handleNodeSelectFromHandler
const handleRequestSettings = handleRequestSettingsFromHandler
const handleCanvasClick = handleCanvasClickFromHandler
const handleComponentAdded = handleComponentAddedFromHandler
const handleComponentRemoved = handleComponentRemovedFromHandler
const handleComponentConfigChanged = handleComponentConfigChangedFromHandler

// üî• Lifecycle management combined functions
// Event listener referenceÔºåfor cleaning
const dataUpdateListener = ref<Function | null>(null)
const statusChangeListener = ref<Function | null>(null)
const pollingStatusListener = ref<Function | null>(null)
const selectedWidgetTimerRef = ref<NodeJS.Timeout | null>(null)

const lifecycleManagerDependencies = {
  // Status management
  isEditing,
  isUnmounted,
  dataFetched,
  multiDataSourceConfigStore,
  selectedWidgetTimer: selectedWidgetTimerRef,

  // Editor features
  stateManager,
  setPreviewMode,
  initializePanelData,
  editorDataSourceManager,
  handleComponentAdded,
  handleComponentRemoved,
  handleComponentConfigChanged,

  // Event listener reference
  dataUpdateListener,
  statusChangeListener,
  pollingStatusListener,

  // Component communication
  emit
}
const { initializeLifecycleManagement: initializeLifecycleManagementFromManager } =
  usePanelLifecycleManager(lifecycleManagerDependencies)

// Using functions from the lifecycle manager
const initializeLifecycleManagement = initializeLifecycleManagementFromManager

// Initialization life cycle management
initializeLifecycleManagement()

const selectedWidget = computed<VisualEditorWidget | null>(() => {
  if (!selectedNodeId.value) return null
  const node = stateManager.nodes.find(node => node.id === selectedNodeId.value)
  if (node) {
    return node as VisualEditorWidget
  }
  return null
})

// Monitor changes in selected componentsÔºåAdd anti-shake
watch(
  () => selectedWidget.value,
  (newWidget, oldWidget) => {
    // Clear previous timer
    if (selectedWidgetTimerRef.value) {
      clearTimeout(selectedWidgetTimerRef.value)
    }

    // Set new timerÔºåAnti-shake100ms
    selectedWidgetTimerRef.value = setTimeout(() => {
      // Only update if components are truly differentselectedNodeId
      if (newWidget?.id !== oldWidget?.id) {
        selectedNodeId.value = newWidget?.id || ''
      }
    }, 100)
  },
  { deep: true }
)

// setState Function has been migrated to usePanelDataManager

// getState Function has been migrated to usePanelDataManager

// fetchBoard Function has been migrated to usePanelDataManager

// parseConfig Function has been migrated to usePanelConfigManager

// validateConfig Function has been migrated to usePanelConfigManager

// migrateConfig Function has been migrated to usePanelConfigManager

// Migrated to /utils/deep-clone.ts

// analyzeCloneability Function has been migrated to usePanelConfigManager

// getDefaultConfig Function has been migrated to usePanelConfigManager

// Renderer options
const rendererOptions = computed(() => [
  { label: $t('visualEditor.canvas'), value: 'canvas' as RendererType },
  { label: $t('visualEditor.gridstack'), value: 'gridstack' as RendererType }
])

// Toolbar event handling
const handleModeChange = (mode: 'edit' | 'preview') => {
  if (mode === 'edit') {
    // üî¥ Turn off global pollingÔºàedit modeÔºâ
    pollingManager.disableGlobalPolling()

    isEditing.value = true
    setPreviewMode(false) // Sync global preview mode

    // üéØ Improve user experienceÔºöAutomatically open the left component library drawer when entering edit mode
    if (!showLeftDrawer.value) {
      showLeftDrawer.value = true
    }
  } else {
    const currentState = getState()
    if (JSON.stringify(currentState) !== JSON.stringify(preEditorConfig.value)) {
      dialog.warning({
        title: $t('card.quitWithoutSave'),
        positiveText: $t('device_template.confirm'),
        negativeText: $t('common.cancel'),
        onPositiveClick: () => {
          // User confirms exitÔºåReset configuration
          isEditing.value = false
          setPreviewMode(true) // Sync global preview mode

          // üîõ Automatically start global pollingÔºàPreview mode is enabled by defaultÔºâ
          initializePollingTasksAndEnable()

          // Close all drawers when exiting edit mode
          showLeftDrawer.value = false
          showRightDrawer.value = false
          // Clear selection
          selectedNodeId.value = ''
          // importantÔºömake sureeditorConfiginisEditingforfalseÔºåAvoid state conflicts
          editorConfig.value = { ...preEditorConfig.value, isEditing: false }
          // importantÔºöcallingsetStateBeforeÔºåmake surepreEditorConfiginisEditingforfalse
          const resetConfig = { ...preEditorConfig.value, isEditing: false }
          setState(resetConfig)
        },
        onNegativeClick: () => {
          // User cancels exitÔºåkeep current statusÔºåDo nothing
        }
      })
    } else {
      // No unsaved changesÔºåExit edit mode directly
      isEditing.value = false
      setPreviewMode(true) // Sync global preview mode

      // üîõ Automatically start global pollingÔºàPreview mode is enabled by defaultÔºâ
      initializePollingTasksAndEnable()

      // Close all drawers when exiting edit mode
      showLeftDrawer.value = false
      showRightDrawer.value = false
      // Clear selection
      selectedNodeId.value = ''
    }
  }
}

// üî• Polling management function

// initializePollingTasksAndEnable Function has been migrated to usePanelPollingManager

// The event handler has been migrated to usePanelEventHandler

// handleAddWidget and handleClearAll Migrated to usePanelEventHandler

// Import and export„ÄÅEvent handling functions such as view control have been migrated to usePanelEventHandler

// Canvas configuration„ÄÅMultiple data source processing functions have been migrated to usePanelEventHandler

/**
 * üî• NewÔºöHandle configuration panel request for current data
 * Provide the current runtime data of the component to the configuration panelÔºåImplement the memory data priority principle
 */
const handleRequestCurrentData = (widgetId: string) => {
  // Get current runtime configuration data
  const currentConfig = multiDataSourceConfigStore.value[widgetId]

  if (currentConfig) {
    // pass ConfigurationManager Temporarily update configurationÔºåMake the configuration panel available
    const tempDataSourceConfig = {
      type: 'data-mapping',
      enabled: true,
      config: currentConfig,
      metadata: {
        componentType: selectedWidget.value?.type || 'unknown',
        mappingType: 'json-path',
        updatedAt: Date.now(),
        isRuntime: true // Mark as runtime data
      }
    }

    // Temporary update ConfigurationManager Data source configuration in
    configurationManager.updateConfiguration(widgetId, 'dataSource', tempDataSourceConfig)
  } else {
  }
}

/**
 * üî• NewÔºöHandling data source manager update events
 * Receive data source configuration updates from the configuration panelÔºåand sync to the editor data source manager
 */
const handleDataSourceManagerUpdate = (updateData: {
  componentId: string
  componentType: string
  config: any
  action: 'update' | 'delete' | 'config-updated' | 'config-restored'
}) => {
  try {
    const { componentId, componentType, config, action } = updateData

    // üî• protectionÔºöMake sure the editor data source manager is initialized and the component exists
    if (!editorDataSourceManager.isInitialized()) {
      return
    }

    // üî• protectionÔºöMake sure the component node exists
    const componentNode = stateManager.nodes.find(n => n.id === componentId)
    if (!componentNode) {
      return
    }

    // üî• protectionÔºöCheck if the configuration is valid
    if (action === 'update' && !config) {
      return
    }

    // üî• repairÔºöSupport new configuration format checking
    if (action === 'update' || action === 'config-updated') {
      // Check multiple configuration formats
      const hasDataSourceBindings = config.dataSourceBindings && Object.keys(config.dataSourceBindings).length > 0
      const hasDataSources =
        config.type === 'data-source-bindings' && (config.dataSource1 || config.dataSource2 || config.dataSource3)

      // üî• NewÔºöSupport configuration format check of new three-file architecture
      const hasNewArchitectureConfig =
        config.config &&
        ((config.config.dataSource1 && config.config.dataSource1.type) ||
          (config.config.dataSource2 && config.config.dataSource2.type) ||
          (config.config.dataSource3 && config.config.dataSource3.type) ||
          (config.config.data && config.config.data.type))

      // üî• NewÔºöCheck if any configuration field contains data source configuration
      const hasAnyDataSourceConfig = config.dataSource1 || config.dataSource2 || config.dataSource3 || config.data

      // üî• NewÔºöCheck that the configuration contains a valid data source type
      const hasValidDataSourceType =
        config.type && ['static', 'api', 'websocket', 'data-source-bindings'].includes(config.type)

      if (
        !hasDataSourceBindings &&
        !hasDataSources &&
        !hasNewArchitectureConfig &&
        !hasAnyDataSourceConfig &&
        !hasValidDataSourceType
      ) {
        return
      }
    }

    if (action === 'update' || action === 'config-updated' || action === 'config-restored') {
      // Update Editor Data Source Manager

      // First check whether the component has been registered
      const existingConfig = editorDataSourceManager.getComponentConfig(componentId)

      if (existingConfig) {
        // Component already existsÔºåDelete first and then re-register to update
        editorDataSourceManager.removeComponentDataSource(componentId)
        editorDataSourceManager.registerComponentDataSource(
          componentId,
          componentType,
          config,
          { type: 'timer', interval: 30000 } // default30Second polling
        )
      } else {
        // Component does not existÔºåNew registration
        editorDataSourceManager.registerComponentDataSource(
          componentId,
          componentType,
          config,
          { type: 'timer', interval: 30000 } // default30Second polling
        )
      }

      // üîß repairÔºöStart the data source immediately after registrationÔºåEnsure that real-time configuration can take effect immediately
      setTimeout(() => {
        editorDataSourceManager.startComponentDataSource(componentId)
      }, 100) // A short delay to ensure registration is complete

      // Sync to local configuration store
      if (config.dataSourceBindings && Object.keys(config.dataSourceBindings).length > 0) {
        multiDataSourceConfigStore.value[componentId] = config
      }
    } else if (action === 'delete') {
      // Delete data source configuration
      editorDataSourceManager.removeComponentDataSource(componentId)

      // Clean local storage
      delete multiDataSourceConfigStore.value[componentId]
      delete multiDataSourceStore.value[componentId]
    }

    // Tags have changed
    hasChanges.value = true
  } catch (error) {
    // üî• protectionÔºöDon‚Äôt affect the overall process when making mistakesÔºåOnly log errors
  }
}

// Canvas operation control„ÄÅRenderer event handling„ÄÅNode selection and interaction functions have been migrated to usePanelEventHandler

// save panel
const handleSave = async () => {
  // Check if it isCanvasRendererÔºåIf so, a developing prompt will be displayed.
  if (currentRenderer.value === 'canvas') {
    message.warning($t('visualEditor.canvasNotSupported'))
    return
  }

  isSaving.value = true
  try {
    const currentState = getState()

    // üîç Save process debugging

    // Parse existing configuration
    let existingConfig: any = {}
    if (panelData.value?.config) {
      try {
        existingConfig = parseConfig(panelData.value.config)
      } catch (error: any) {}
    }

    // Build the basic configuration firstÔºàNot included configSizeÔºâ
    const baseConfig = {
      legacyComponents: existingConfig.legacyComponents || [],
      visualEditor: {
        ...currentState,
        metadata: {
          version: '1.0.0',
          updatedAt: Date.now(),
          editorType: 'visual-editor',
          // Panel basic information
          panelInfo: {
            id: props.panelId,
            name: panelData.value?.name || '',
            homeFlag: panelData.value?.home_flag || false,
            createdAt: panelData.value?.created_at || Date.now(),
            updatedAt: Date.now()
          },
          // Editor version information
          editorVersion: '1.0.0',
          // Renderer information
          rendererInfo: {
            type: currentRenderer.value,
            version: '1.0.0',
            features: ['drag', 'resize', 'grid', 'canvas']
          },
          // Configure statistics
          stats: {
            totalNodes: currentState.nodes.length,
            card2Nodes: currentState.nodes.filter((node: any) => node.metadata?.isCard2Component).length,
            legacyNodes: currentState.nodes.filter((node: any) => !node.metadata?.isCard2Component).length,
            hasGridConfig: !!currentState.gridConfig,
            hasCanvasConfig: !!currentState.canvasConfig,
            configSize: 0 // initial valueÔºåwill be updated later
          }
        }
      }
    }

    // Configuration sizes can now be calculated safely
    const configSize = JSON.stringify(baseConfig).length
    baseConfig.visualEditor.metadata.stats.configSize = configSize
    const { error } = await PutBoard({
      id: props.panelId,
      config: JSON.stringify(baseConfig),
      name: panelData.value?.name,
      home_flag: panelData.value?.home_flag
    })

    if (!error) {
      // üî• Smart deep copyÔºöUse optimizedsmartDeepClone
      preEditorConfig.value = smartDeepClone(currentState)
      hasChanges.value = false
      message.success($t('page.dataForward.saveSuccess'))
    } else {
      message.error($t('page.dataForward.saveFailed'))
    }
  } catch (err: any) {
    message.error($t('page.dataForward.saveFailed'))
  } finally {
    isSaving.value = false
  }
}

// Monitor status changesÔºåAutomatically set hasChanges
watch(
  [
    () => currentRenderer.value,
    () => showWidgetTitles.value,
    () => showLeftDrawer.value,
    () => showRightDrawer.value,
    () => editorConfig.value.gridConfig,
    () => editorConfig.value.canvasConfig,
    () => stateManager.nodes
  ],
  () => {
    // Only listen for changes after data loading is complete
    if (dataFetched.value && !isUnmounted.value) {
      hasChanges.value = true
    }
  },
  { deep: true }
)

/**
 * Monitor component node changesÔºåAutomatically sync data source manager
 */
watch(
  () => stateManager.nodes,
  (newNodes, oldNodes) => {
    if (!editorDataSourceManager.isInitialized()) return

    // Handle new components
    const newNodeIds = newNodes.map(n => n.id)
    const oldNodeIds = oldNodes?.map(n => n.id) || []

    // Register new components
    const addedNodeIds = newNodeIds.filter(id => !oldNodeIds.includes(id))
    addedNodeIds.forEach(async nodeId => {
      const node = newNodes.find(n => n.id === nodeId)
      if (node) {
        try {
          await editorDataSourceManager.registerComponent(nodeId, {
            type: node.type || 'unknown',
            name: node.title || node.id,
            dataSources: multiDataSourceConfigStore.value[nodeId] || {},
            dataRequirements: node.dataRequirements || {}
          })
        } catch (error) {}
      }
    })

    // Unregister removed components
    const removedNodeIds = oldNodeIds.filter(id => !newNodeIds.includes(id))
    removedNodeIds.forEach(async nodeId => {
      try {
        await editorDataSourceManager.removeComponentDataSource(nodeId)
      } catch (error) {}
    })
  },
  { deep: true }
)

/**
 * Synchronize the data source configuration of existing components to the editor data source manager
 */
/**
 * Set up data source event listener
 * Listening to data source manager eventsÔºåImplement data distribution
 */
const setupDataSourceEventListeners = () => {
  try {
    // Create listener function and save reference
    dataUpdateListener = (eventData: { componentId: string; result: any }) => {
      const { componentId, result } = eventData

      // üî• Performance optimizationÔºöReduce unnecessary console output

      if (result.success && result.data) {
        try {
          // üî• Performance optimizationÔºöCheck if the data actually changedÔºåAvoid unnecessary responsive updates
          const existingData = multiDataSourceStore.value[componentId]
          const hasDataChanged = !existingData || JSON.stringify(existingData) !== JSON.stringify(result.data)

          if (hasDataChanged) {
            // üî• keyÔºöDistribute data to multiDataSourceStoreÔºåfor component use
            multiDataSourceStore.value[componentId] = result.data
          } else {
            // Data has not changedÔºåSkip updates
          }

          // Tags have changedÔºàOptionalÔºåDepends on whether you want data updates to trigger a save promptÔºâ
          // hasChanges.value = true
        } catch (error) {}
      } else {
      }
    }

    statusChangeListener = (eventData: { componentId: string; status: string; error?: string }) => {
      const { componentId, status, error } = eventData

      // üî• Performance optimizationÔºöOnly output status change logs in the development environment

      if (error) {
        // üî• TODO: User friendly error notifications can be added hereUI
        // message.error(`components ${componentId} Data acquisition failed: ${error}`)
      }
    }

    pollingStatusListener = (eventData: { componentId: string; isPolling: boolean }) => {
      const { componentId, isPolling } = eventData

      // üî• Performance optimizationÔºöOnly output polling status log in development environment
    }

    // Register listener
    editorDataSourceManager.on('data-updated', dataUpdateListener)
    editorDataSourceManager.on('component-status-changed', statusChangeListener)
    editorDataSourceManager.on('polling-status-changed', pollingStatusListener)
  } catch (error) {}
}

/**
 * Set up component lifecycle listeners
 * Adding a listening component„ÄÅdelete„ÄÅConfiguration changes and other events
 */
// setupComponentLifecycleListeners Migrated to usePanelLifecycleManager

// Component lifecycle event handlers have been migrated to usePanelEventHandler

const syncDataSourceConfigs = async () => {
  try {
    // Traverse all nodesÔºåCheck if there is data source configuration
    for (const node of stateManager.nodes) {
      if (node && node.id) {
        // Check if multiple data source configuration exists
        const multiConfig = multiDataSourceConfigStore.value[node.id]
        if (multiConfig && Object.keys(multiConfig).length > 0) {
          // Register the component to the data source manager
          await editorDataSourceManager.registerComponent(node.id, {
            type: node.type || 'unknown',
            name: node.title || node.id,
            dataSources: multiConfig,
            dataRequirements: node.dataRequirements || {}
          })
        }
      }
    }
  } catch (error) {}
}

/**
 * üî• Add dual data source test components developed according to the new architecture
 * add a dual-data-display componentsÔºåConfigure two data sources for testing the new architecture
 */
const addNewArchitectureTestComponent = async () => {
  try {
    // Create a dual-data-display Component instance
    const testComponentId = `dual-data-display-${Date.now()}`

    const testComponent: VisualEditorWidget = {
      id: testComponentId,
      type: 'dual-data-display',
      name: 'Dual data source display component',
      layout: {
        canvas: {
          x: 50,
          y: 50,
          width: 500,
          height: 350,
          zIndex: 1
        },
        gridstack: {
          x: 0,
          y: 0,
          w: 4,
          h: 4
        }
      },
      config: {
        // üî• Configure two data sources for testing the new architecture
        dataSources: {
          dataSource1: {
            type: 'static',
            enabled: true,
            config: {
              data: {
                sensor: 'temperature',
                value: 25.8,
                unit: '¬∞C',
                status: 'normal',
                location: 'engine roomA-01',
                timestamp: new Date().toISOString()
              }
            }
          },
          dataSource2: {
            type: 'static',
            enabled: true,
            config: {
              data: {
                device: 'humidity_sensor',
                reading: 62,
                unit: '%',
                status: 'active',
                location: 'engine roomA-02',
                lastCheck: new Date().toISOString()
              }
            }
          }
        }
      },
      metadata: {
        addedAt: Date.now(),
        version: '2.0.0',
        architecture: 'dual-data-source-flow'
      }
    }

    // Add components to the canvasÔºàOnly pass type string and positionÔºâ
    await addWidget('dual-data-display', { x: 50, y: 50 })

    // Get the newly added componentIDÔºàfromstateManager.nodesFind the latest inÔºâ
    const addedComponent = stateManager.nodes[stateManager.nodes.length - 1]
    const actualComponentId = addedComponent?.id || testComponentId

    // Update the data source configuration of the component
    updateNode(actualComponentId, {
      config: testComponent.config,
      metadata: {
        ...addedComponent?.metadata,
        ...testComponent.metadata
      }
    })

    // Select the newly added component
    selectNode(actualComponentId)

    return actualComponentId
  } catch (error) {
    throw error
  }
}

// Initialize the core logic of panel data and configuration
// initializePanelData Function has been migrated to usePanelDataManager

// Component initialization and tab refresh monitoring have been migrated to usePanelLifecycleManager

// Expose methods for parent components to use
defineExpose({
  initializePollingTasksAndEnable
})

// Component lifecycle managementÔºàRestoring a multiple data source configuration„ÄÅEvent listener cleanup„ÄÅonUnmountedÔºâMigrated to usePanelLifecycleManager
</script>

<template>
  <div
    class="panel-editor-root"
    :class="{ 'px-5 py-5': props.showPageHeader !== false || props.showToolbar !== false }"
  >
    <!-- Page title bar - according to showPageHeader prop control display -->
    <div
      v-show="!appStore.fullContent && props.showPageHeader !== false"
      class="flex items-center justify-between border-b border-gray-200 px-10px pb-3 dark:border-gray-200/10"
    >
      <div>
        <NSpace align="center">
          <span class="text-14px font-medium line-height-normal">
            {{ $t('card.dashboard') }}Ôºö{{ panelData?.name }}
          </span>
        </NSpace>
      </div>
      <NSpace align="center">
        <FullScreen :full="isFullscreen" @click="toggle" />
      </NSpace>
    </div>

    <!-- Editor area -->
    <div ref="fullui" class="h-edit-area flex bg-white">
      <div v-if="!dataFetched" class="h-full flex items-center justify-center w-full">
        <n-spin size="large">
          <template #description>
            {{ $t('visualEditor.loading') }}
          </template>
        </n-spin>
      </div>

      <div v-else class="panel-editor w-full h-full flex flex-col">
        <!-- Toolbar - according to showToolbar prop control display -->
        <div v-if="props.showToolbar !== false" class="toolbar-container flex-shrink-0">
          <VisualEditorToolbar
            v-if="dataFetched && !isUnmounted"
            :key="`toolbar-${currentRenderer}-${isPreviewMode ? 'preview' : 'edit'}`"
            :mode="isPreviewMode ? 'preview' : 'edit'"
            :current-renderer="currentRenderer"
            :available-renderers="rendererOptions"
            :is-saving="isSaving"
            :has-changes="hasChanges"
            :show-left-drawer="showLeftDrawer"
            :show-right-drawer="showRightDrawer"
            :gridstack-config="editorConfig.gridConfig"
            :canvas-config="editorConfig.canvasConfig"
            @mode-change="handleModeChange"
            @renderer-change="handleRendererChange"
            @save="handleSave"
            @import="handleImportConfig"
            @export="handleExportConfig"
            @import-config="handleImportConfig"
            @export-config="handleExportConfig"
            @undo="handleUndo"
            @redo="handleRedo"
            @clear-all="handleClearAll"
            @zoom-in="handleZoomIn"
            @zoom-out="handleZoomOut"
            @reset-zoom="handleResetZoom"
            @toggle-left-drawer="handleToggleLeftDrawer"
            @toggle-right-drawer="handleToggleRightDrawer"
            @gridstack-config-change="handleGridstackConfigChange"
            @canvas-config-change="handleCanvasConfigChange"
          />
        </div>

        <!-- main content area -->
        <div class="main-container flex-1 relative overflow-hidden" :class="{ dragging: isDragging }">
          <!-- central canvas -->
          <div class="canvas-container h-full w-full" @click="handleCanvasClick">
            <!-- dynamic renderer -->
            <CanvasRenderer
              v-if="currentRenderer === 'canvas' && dataFetched && !isUnmounted"
              key="canvas-renderer"
              :readonly="isPreviewMode"
              :show-widget-titles="showWidgetTitles"
              class="renderer-container"
              @ready="handleRendererReady"
              @error="handleRendererError"
              @node-select="handleNodeSelect"
              @canvas-click="handleCanvasClick"
              @request-settings="handleRequestSettings"
            />
            <GridstackRenderer
              v-else-if="currentRenderer === 'gridstack' && dataFetched && !isUnmounted"
              key="gridstack-renderer"
              :readonly="isPreviewMode"
              :show-widget-titles="showWidgetTitles"
              :grid-config="editorConfig.gridConfig"
              :multi-data-source-store="multiDataSourceStore"
              :multi-data-source-config-store="multiDataSourceConfigStore"
              class="renderer-container"
              @ready="handleRendererReady"
              @error="handleRendererError"
              @node-select="handleNodeSelect"
              @canvas-click="handleCanvasClick"
              @request-settings="handleRequestSettings"
            />
          </div>

          <!-- Left component library drawer -->
          <NDrawer
            v-model:show="showLeftDrawer"
            :width="320"
            placement="left"
            :show-mask="false"
            :mask-closable="true"
            :closable="true"
            :auto-focus="false"
            :z-index="1000"
            :trap-focus="false"
          >
            <NDrawerContent :title="$t('visualEditor.componentLibrary')" :native-scrollbar="false">
              <WidgetLibrary @add-widget="handleAddWidget" @drag-start="handleDragStart" @drag-end="handleDragEnd" />
            </NDrawerContent>
          </NDrawer>

          <!-- Right properties panel drawer -->
          <NDrawer
            v-model:show="showRightDrawer"
            :width="450"
            placement="right"
            :show-mask="true"
            :mask-closable="true"
            :closable="true"
            :auto-focus="false"
            :z-index="1000"
            :trap-focus="false"
          >
            <NDrawerContent :title="$t('visualEditor.propertySettings')" :native-scrollbar="false">
              <ConfigurationPanel
                :selected-widget="selectedWidget"
                :show-widget-titles="showWidgetTitles"
                :grid-config="editorConfig.gridConfig"
                :preview-mode="isPreviewMode"
                :global-polling-enabled="globalPollingEnabled"
                @toggle-widget-titles="handleToggleWidgetTitles"
                @grid-config-change="handleGridConfigChange"
                @multi-data-source-update="handleMultiDataSourceUpdate"
                @multi-data-source-config-update="handleMultiDataSourceConfigUpdate"
                @request-current-data="handleRequestCurrentData"
                @data-source-manager-update="handleDataSourceManagerUpdate"
              />
            </NDrawerContent>
          </NDrawer>
        </div>

        <!-- Low profile polling controller - Only shown in preview mode -->
        <PollingController
          v-if="isPreviewMode && dataFetched"
          mode="global"
          position="bottom-right"
          :show-stats="true"
          :low-profile="true"
          @polling-toggle="handlePollingToggle"
          @polling-enabled="handlePollingEnabled"
          @polling-disabled="handlePollingDisabled"
        />
      </div>
    </div>
  </div>
</template>

<style scoped>
/* üî• Core fixÔºöPanelEditor Root container height settings */
.panel-editor-root {
  width: 100%;
  height: 100%;
  min-height: 100vh; /* Make sure you have at least the viewport height */
}

.panel-editor {
  min-height: 600px;
  /* üî• strengthenÔºöMake sure the editor is tall enough in any case */
  height: 100%;
}

.h-edit-area {
  height: calc(100% - 30px);
  /* üî• critical fixÔºöWhen the height of the parent container is unclearÔºåUse viewport height as baseline */
  min-height: calc(100vh - 160px); /* minus the head„ÄÅNavigation and other fixed heights */
}

/* canvas container */
.canvas-container {
  position: relative;
  width: 100%;
  height: 100%;
  /* üî• critical fixÔºöCanvas container sets minimum heightÔºåMake sure the grid area is visible */
  min-height: 600px;
  overflow: hidden;
  background-color: var(--n-body-color);
}

.renderer-container {
  width: 100%;
  height: 100%;
  /* üî• Grid layout requires fixed heightÔºåCannot be usedoverflow:auto */
  min-height: 500px;
  position: relative;
}

/* Drag state style */
.main-container.dragging .n-drawer {
  opacity: 0.3;
  transition: opacity 0.2s ease;
}

.main-container.dragging .n-drawer-mask {
  pointer-events: none;
}

/* Make sure the dragged element is at the top level */
.dragging-element {
  position: fixed;
  z-index: 9999 !important;
  pointer-events: none;
}

/* Drawer content optimization */
:deep(.n-drawer-content) {
  height: 100%;
}

:deep(.n-drawer-content .n-drawer-content__content) {
  padding: 0;
  height: 100%;
}

/* Special style of left drawer - Translucent effectÔºåDoes not affect dragging */
:deep(.n-drawer--left) {
  background-color: rgba(250, 250, 250, 0.9) !important;
  backdrop-filter: blur(8px);
  -webkit-backdrop-filter: blur(8px);
}

:deep(.n-drawer--left .n-drawer-content) {
  background-color: rgba(250, 250, 250, 0.9) !important;
  backdrop-filter: blur(8px);
  -webkit-backdrop-filter: blur(8px);
}

/* Left drawer in dark theme */
:deep(.dark .n-drawer--left) {
  background-color: rgba(37, 37, 37, 0.9) !important;
}

:deep(.dark .n-drawer--left .n-drawer-content) {
  background-color: rgba(37, 37, 37, 0.9) !important;
}

/* Enhanced shadow effect on the right drawer */
:deep(.n-drawer--right) {
  box-shadow: -4px 0 12px rgba(0, 0, 0, 0.15);
}

/* toolbar container */
.toolbar-container {
  border-bottom: 1px solid #e0e0e0;
  background-color: #fff;
}

/* Responsive design */
@media (max-width: 768px) {
  .panel-editor {
    min-height: 400px;
  }
}
</style>
